<!DOCTYPE html>
<html>
<head>
  
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<meta charset="utf-8" />
  <title>My Web DAW v71</title>
  <style>
    body { font-family: system-ui, -apple-system, sans-serif; margin: 16px; }
    h1 { margin: 0 0 6px; }
    .legend { margin: 8px 0 12px; color: #555; font-size: 14px; }

    .toolbar {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 12px;
    }
    .toolbar input { width: 80px; }

    .topbar, .pianoroll {
      display: grid;
      grid-template-columns: 70px 1fr;
      gap: 8px;
      align-items: start;
      max-width: 980px;
    }
    .topbar { margin-bottom: 6px; }

    .labels {
      display: grid;
      gap: 0;              /* âœ… ì¤„ê°„ê²© ì—†ì• ì„œ ê·¸ë¦¬ë“œë‘ ì¼ì¹˜ */
      padding-top: 1px;    /* âœ… gridì˜ ë°”ê¹¥ border(1px)ë§Œí¼ ë§ì¶¤ */
      border: 1px solid #ddd;
      border-right: none; /* ë¼ë²¨-ê·¸ë¦¬ë“œ ì‚¬ì´ ì¤‘ë³µ ì„  ë°©ì§€ */
      border-radius: 4px 0 0 4px;
      overflow: hidden;
    }

    .label {
      height: 22px;
      box-sizing: border-box;             /* âœ… borderê°€ height ì•ˆì— í¬í•¨ë˜ê²Œ */
      border-bottom: 1px solid #e6e6e6;   /* âœ… grid cellê³¼ ê°™ì€ ê°€ë¡œ ì¤„ */
      border-radius: 0;                   /* âœ… ì¤„ ì •ë ¬ì´ ë” ë˜ë ·í•´ì§(ì›í•˜ë©´ ë‹¤ì‹œ 4px ì¤˜ë„ ë¨) */
    }


    /* íƒ€ì„ë¼ì¸ */
    .timeline { display: grid; font-size: 12px; color: #333; }
    .tick {
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f8f8f8;
      border: 1px solid #e6e6e6;
      border-left: none;
    }
    .tick:first-child { border-left: 1px solid #e6e6e6; }
    .tick.bar { font-weight: 600; background: #f1f1f1; }

    /* ê·¸ë¦¬ë“œ + ë…¸íŠ¸ ì˜¤ë²„ë ˆì´ */
    .gridWrap {
      position: relative;
      width: fit-content;
      touch-action: none;
    }
    .grid {
      display: grid;
      border: 1px solid #ddd;
      background: #fff;
    }
    .cell {
      width: 22px;
      height: 22px;
      border-right: 1px solid #e6e6e6;
      border-bottom: 1px solid #e6e6e6;
      cursor: pointer;
      background: transparent;
      user-select: none;
    }
    /* ë§ˆë”” ì‹œì‘ (êµµì€ ì„ ) */
    .cell.barline { border-left: 2px solid rgba(0,0,0,0.14); }
    /* ë°• ì‹œì‘ (ì—°í•œ ì„ ) */
    .cell.beatline { box-shadow: inset 1px 0 0 rgba(0,0,0,0.08); }

    /* ë…¸íŠ¸ ë ˆì´ì–´ */
    .notesLayer {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }
    .note {
      position: absolute;
      height: 22px;
      border-radius: 4px;
      background: #4a90e2;
      box-shadow: 0 0 0 1px rgba(0,0,0,0.08) inset;
    }
    .note.editing {
      box-shadow:
        0 0 0 2px rgba(0,0,0,0.25) inset,
        0 0 0 1px rgba(0,0,0,0.10);
    }

    button:focus { outline: none; }
  
    .cell.outKey { background: #f2f2f2; }
    .label.outKey { color: #999; background: #fafafa; }

  /* í”Œë ˆì´í—¤ë“œ(í¬ì§€ì…˜ ë°”) */
  .playhead {
    position: absolute;
    top: 0;
    bottom: 0;
    width: 2px;
    background: rgba(220, 0, 0, 0.85);
    pointer-events: none;
    transform: translateX(-1px);
  }
  .playhead.hidden { display: none; }

    /* Insert length buttons */
    .seg {
      display: inline-flex;
      border: 1px solid #ddd;
      border-radius: 10px;
      overflow: hidden;
      vertical-align: middle;
    }
    .seg button {
      border: 0;
      padding: 6px 10px;
      background: #fff;
      cursor: pointer;
      font-size: 13px;
      line-height: 1;
    }
    .seg button + button { border-left: 1px solid #ddd; }
    .seg button.active { background: #111; color: #fff; }

  
/* =========================
   Mobile / Responsive
   ========================= */
:root{
  --cellW: 22px;
  --cellH: 18px;
  --labelW: 70px;
  --playheadW: 2px;
}
.topbar, .pianoroll{ max-width: 100%; width: 100%; }
.pianoroll{ grid-template-columns: var(--labelW) minmax(0, 1fr); }
.gridwrap{
  overflow-x: auto;
  overflow-y: hidden;
  -webkit-overflow-scrolling: touch;
  touch-action: pan-x; /* allow horizontal scroll by default */
  border-radius: 10px;
}
.grid{ min-width: calc(var(--cellW) * 64); }
.cell{ width: var(--cellW); height: var(--cellH); }
.note{ height: calc(var(--cellH) - 2px); }
.playhead{ width: var(--playheadW) !important; }

.toolbar button, .toolbar select, .toolbar input{ min-height: 36px; font-size: 14px; }

@media (max-width: 520px){
  :root{ --cellW: 22px; --cellH: 20px; --labelW: 58px; --playheadW: 2px; }
  body{ margin: 10px; }
  h1{ font-size: 18px; }
  .legend{ font-size: 12px; }
  .toolbar button, .toolbar select, .toolbar input{ min-height: 42px; font-size: 16px; }
  .toolbar input{ width: 90px; }
}
  
/* Prevent iOS long-press text selection/callout on the piano roll */
.pianoroll, .labels, .gridwrap, .grid, .cell, .note, .ruler, .rulerCell {
  -webkit-user-select: none;
  user-select: none;
  -webkit-touch-callout: none;
}
  
/* Editing state outline colors */
.note.editing { outline: 2px solid #111; }
.note.editing.moving { outline: 2px solid #d00; }
  
  .partheader {
    max-width: 980px;
    padding: 10px;
    margin-bottom: 6px;
    border-radius: 6px;
    color: #fff;
    font-weight: 600;
    font-size: 14px;
  }

    .readonly #grid, .readonly #notesLayer { pointer-events: none; }
    .readonlyHint { font-size: 12px; color:#666; margin:6px 0 0; }
:root{
  --bg-scale: #d9d9d9;     /* in key, not chord tone */
  --bg-nonscale: #9a9a9a;  /* not in key */
  --bg-chord: #ffffff;     /* chord tone */
}
body.presetActive .cell { background: var(--bg-nonscale); }
body.presetActive .cell.scale { background: var(--bg-scale); }
body.presetActive .cell.chord { background: var(--bg-chord); }

    .trackbar{display:flex;gap:6px;align-items:center;flex-wrap:wrap;margin:6px 0 10px}
    .trackbar .tbtn{border:1px solid #444;background:#1f1f1f;color:#eee;padding:6px 10px;border-radius:10px;font-size:14px;cursor:pointer}
    .trackbar .tbtn.active{border-color:#fff;box-shadow:0 0 0 2px rgba(255,255,255,.15) inset}
    .trackbar .pill{display:inline-flex;align-items:center;gap:6px;margin-left:6px;font-size:12px;color:#bbb}
    .dot{width:10px;height:10px;border-radius:50%;display:inline-block}

</style>


</head>

<body>
  <h1>My Web DAW v71</h1>
  <div class="toolbar">
  <div class="trackbar" id="trackBar">
    <button class="tbtn" data-track="melody" title="Melody (í¸ì§‘ ëŒ€ìƒ)">Melody</button>
    <button class="tbtn" data-track="keys" title="Keys (ì½”ë“œ/ê±´ë°˜)">Keys</button>
    <button class="tbtn" data-track="bass" title="Bass">Bass</button>
    <button class="tbtn" data-track="drums" title="Drums (ë“œëŸ¼ UIëŠ” ë‹¤ìŒ ë‹¨ê³„)">Drums</button>
    <span class="pill">Selected: <span class="dot" id="trackDot" style="background:#2b7cff"></span><span id="trackLabel">melody</span></span>
  </div>

    <button onclick="play()">ì¬ìƒ</button>
    <button onclick="stop()">ì •ì§€</button>
    <button onclick="exportMidi()">MIDIë¡œ ì €ì¥</button>
    <button onclick="undo()">Undo</button>

    <span style="margin-left:10px;">BPM</span>
    <input id="bpm" type="number" min="30" max="240" step="1" value="90" />
    <button onclick="applyBpm()">ì ìš©</button>
    <span style="margin-left:10px;">Range</span>
    <select id="rangeSel">
      <option value="full">Full (C3â€“B4)</option>
      <option value="male" selected>Male (E3â€“A4)</option>
      <option value="female">Female (G3â€“C5)</option>
    </select>



    <span style="margin-left:12px;">Key</span>
    <select id="keyRoot" onchange="applyKey()">
      <option value="0" selected>C</option>
      <option value="1">C#</option>
      <option value="2">D</option>
      <option value="3">D#</option>
      <option value="4">E</option>
      <option value="5">F</option>
      <option value="6">F#</option>
      <option value="7">G</option>
      <option value="8">G#</option>
      <option value="9">A</option>
      <option value="10">A#</option>
      <option value="11">B</option>
    </select>
    <select id="scaleType" onchange="applyKey()">
      <option value="major" selected>Major</option>
      <option value="minor">Natural Minor</option>
    </select>

    <span style="margin-left:10px;">Insert Len</span>
    <span class="seg" id="insertLenSeg">
      <button type="button" data-len="4">1/4</button>
      <button type="button" data-len="2">1/8</button>
      <button type="button" data-len="1" class="active">1/16</button>
    </span>

<span style="margin-left:12px;">Chord Preset</span>
<select id="chordPresetSel">
  <option value="">(none)</option>
  <option value="p1">1) Iâ€“iiiâ€“IVâ€“V (Câ€“Emâ€“Fâ€“G)</option>
  <option value="p2">2) Iâ€“viâ€“IVâ€“V (Câ€“Amâ€“Fâ€“G)</option>
  <option value="p3">3) Iâ€“Vâ€“viâ€“IV (Câ€“Gâ€“Amâ€“F)</option>
</select>
<label style="display:inline-flex;align-items:center;gap:6px;margin-left:10px;">
  <input type="checkbox" id="autoChordToggle" />
  Auto Chords
</label>

    <span style="margin-left:12px;">Parts</span>
    <button onclick="setViewMode('full')">Full</button>
    <button onclick="setViewMode('part')">Part</button>
<button onclick="switchPart('verseA1')">Verse A 1/2</button>
<button onclick="switchPart('verseA2')">Verse A 2/2</button>
<button onclick="switchPart('pre1')">Pre 1/2</button>
<button onclick="switchPart('pre2')">Pre 2/2</button>
<button onclick="switchPart('chorus1')">Chorus 1/2</button>
<button onclick="switchPart('chorus2')">Chorus 2/2</button>

<span style="margin-left:12px;">Chords</span>
    <button onclick="playChord(1)">I</button>
    <button onclick="playChord(2)">ii</button>
    <button onclick="playChord(3)">iii</button>
    <button onclick="playChord(4)">IV</button>
    <button onclick="playChord(5)">V</button>
    <button onclick="playChord(6)">vi</button>
    <button onclick="playChord(7)">viiÂ°</button>


    <button onclick="clearNotes()" style="margin-left:auto;">ë…¸íŠ¸ ì „ì²´ ì‚­ì œ</button>
  
</div>

  <div class="legend">
    16ë¶„ í•´ìƒë„(1ë°•=4ì¹¸) Â· 4ë§ˆë”” Â· í´ë¦­=ìƒì„±(16ë¶„ 1ì¹¸) Â· ë“œë˜ê·¸=ê¸¸ì´ Â· ì‹œì‘ì¹¸ í´ë¦­=ì‚­ì œ Â· Cmd/Ctrl+Z=Undo
  </div>

  <div class="partheader" id="partHeader"></div>
<div class="topbar">
    <div></div>
    <div id="timeline" class="timeline"></div>
  </div>

  <div class="pianoroll">
    <div id="labels" class="labels"></div>

    <div class="gridWrap" id="gridWrap">
      <div class="gridwrap"><div id="grid" class="grid"></div></div>
      <div id="notesLayer" class="notesLayer"></div>
      <div id="playhead" class="playhead hidden"></div>
    </div>
  </div>

  <script src="https://unpkg.com/tone/build/Tone.js">
// FIRST_GESTURE_AUDIO_PRIME
(function(){
  function onFirstGesture(){
    try { if (typeof primeAudio==='function') primeAudio();
  } catch(e) {}
  }
  document.addEventListener('touchstart', onFirstGesture, { once:true, capture:true, passive:false });
  document.addEventListener('pointerdown', onFirstGesture, { once:true, capture:true, passive:false });
})();

</script>
  <script src="https://unpkg.com/@tonejs/midi/build/Midi.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/soundfont-player@0.12.0/dist/soundfont-player.min.js"></script>

  <script>

    // =========================
    // ì„¤ì •
    // =========================
    const CELL = 22;
    const SUBDIV = 4; // 1ë°•(4ë¶„) = 4ì¹¸ = 16ë¶„ í•´ìƒë„

    // =========================
    // í”„ë¡œì íŠ¸ ë°ì´í„°
    // =========================
    
// =========================
// Project / Parts Structure (v39)
// =========================
const PART_DEFS = [
  { id: "verseA1",  label: "Verse A (1/2)",  color: "#4a90e2" },
  { id: "verseA2",  label: "Verse A (2/2)",  color: "#6aa8f0" },
  { id: "pre1",     label: "Pre-Chorus (1/2)", color: "#5cb85c" },
  { id: "pre2",     label: "Pre-Chorus (2/2)", color: "#7ad07a" },
  { id: "chorus1",  label: "Chorus (1/2)", color: "#d9534f" },
  { id: "chorus2",  label: "Chorus (2/2)", color: "#e57373" },
];

// === Track scaffold (v58) ===
// We keep the existing single visible/editable piano-roll UI,
// but internally each part owns 4 tracks. For now, the editor
// always targets the activeTrackId ("melody" by default).
const TRACK_DEFS = [
  { id: "melody", label: "Melody", type: "pitched" },
  { id: "keys",   label: "Keys",   type: "pitched" },
  { id: "bass",   label: "Bass",   type: "pitched" },
  { id: "drums",  label: "Drums",  type: "drum"   }
];

let activeTrackId = "melody";


const TRACK_COLORS = {
  melody: "#2b7cff",
  keys:   "#8e44ad",
  bass:   "#16a085",
  drums:  "#c0392b"
};

function updateTrackUI() {
  const bar = document.getElementById("trackBar");
  if (!bar) return;
  bar.querySelectorAll(".tbtn").forEach(b => {
    b.classList.toggle("active", b.dataset.track === activeTrackId);
  });
  const dot = document.getElementById("trackDot");
  const lbl = document.getElementById("trackLabel");
  if (dot) dot.style.background = TRACK_COLORS[activeTrackId] || "#999";
  if (lbl) lbl.textContent = activeTrackId;
}

function switchTrack(newId) {
  if (!newId || newId === activeTrackId) return;

  // Save current visible notes into current track
  syncToPart();

  // Switch track
  activeTrackId = newId;

  // Load new track notes into editor buffer
  syncFromPart();

  renderNotes();
  updateTrackUI();
}


function bindTrackUI() {
  const bar = document.getElementById("trackBar");
  if (!bar) return;
  bar.querySelectorAll(".tbtn").forEach(b => {
    b.addEventListener("click", () => switchTrack(b.dataset.track));
  });
  updateTrackUI();
}
function ensurePartTracks(partObj) {
  if (partObj.tracks) return;
  partObj.tracks = {};
  TRACK_DEFS.forEach(t => {
    partObj.tracks[t.id] = { notes: [] };
  });
}

function getActiveTrackNotes() {
  const part = project.parts[project.currentPartId];
  if (!part) return [];
  ensurePartTracks(part);
  return part.tracks[activeTrackId].notes;
}

const project = {
  bpm: 90,
  timeSignature: [4, 4],
  bars: 4,               // each part is always 4 bars
  currentPartId: "verseA1",
  parts: {},
  tracks: [{ name: "Piano", notes: [] }]
};

PART_DEFS.forEach(p => {
  project.parts[p.id] = {}; ensurePartTracks(project.parts[p.id]);
});

function syncFromPart() {
  project.tracks[0].notes = getActiveTrackNotes();
}
function syncToPart() {
  const part = project.parts[project.currentPartId];
  ensurePartTracks(part);
  part.tracks[activeTrackId].notes = project.tracks[0].notes;
}


function getPartNotes(partId) {
  const part = project.parts[partId];
  if (!part) return [];
  ensurePartTracks(part);
  return part.tracks["melody"].notes; // v58: legacy behavior = melody only
}
// start on Verse A (1/2)
syncFromPart();
// =========================
// View mode: part vs full (v42)
// =========================
let viewMode = "part";
let lastInsertStep = 1; // "part" | "full"

function recomputeCols() {
  totalCols = project.bars * beatsPerBar * SUBDIV;
}

function rebuildUIAfterBarsChange() {
  recomputeCols();
  buildTimeline();
  buildGrid();
  renderNotes();
  updatePlayheadVisual(cursorCol);
}

function buildCombinedNotesForFull() {
  // persist current part edits first
  syncToPart();

  const combined = [];
  let gid = 100000;
  PART_DEFS.forEach((p, i) => {
    const offset = i * 4; // 4 bars per part
    const notes = getPartNotes(p.id) || [];
    notes.forEach(n => {
      combined.push({
        id: gid++,
        bar: n.bar + offset,
        beat: n.beat,
        length: n.length,
        pitch: n.pitch
      });
    });
  });
  return combined;
}

function setViewMode(mode) {
  if (mode === viewMode) return;

  if (mode === "full") {
    viewMode = "full";
    project.bars = 24; // 6 parts * 4 bars
    // show combined notes in the visible track (read-only mode)
    project.tracks[0].notes = buildCombinedNotesForFull();
  } else {
    // back to part editing
    viewMode = "part";
    project.bars = 4;
    syncFromPart();
  }

  // disable editing interactions in full view
  gridEl.classList.toggle("readonly", viewMode === "full");

  rebuildUIAfterBarsChange();
  updatePartHeader();
}

window.setViewMode = setViewMode;



// =========================
// Part Switching (v40)
// =========================
function updatePartHeader() {
  const h = document.getElementById("partHeader");
  if (!h) return;
  if (typeof viewMode !== "undefined" && viewMode === "full") {
    h.textContent = "Full View Â· 24 Bars (Read-only)";
    h.style.background = "#111";
    return;
  }
  const p = PART_DEFS.find(x => x.id === project.currentPartId);
  if (!p) return;
  h.textContent = p.label + " Â· 4 Bars";
  h.style.background = p.color;
}

// paint initial part header
updatePartHeader();

function switchPart(partId) {
  if (!project.parts[partId]) return;

  // save current visible notes into the current part
  syncToPart();

  // switch
  project.currentPartId = partId;

  // load selected part notes into visible track
  syncFromPart();

  renderNotes();
  updateTrackUI();
updatePartHeader();
}

// expose for inline onclick
window.switchPart = switchPart;


    // =========================
    // í”¼ì•„ë…¸ë¡¤ ì„¤ì •
    // =========================
    const PITCH_MIN = 48; // C3
    const PITCH_MAX = 71; // B4

    const beatsPerBar = project.timeSignature[0]; // 4
    let totalCols = project.bars * beatsPerBar * SUBDIV; // 4 bars * 4 beats * 4 = 64

    let pitches = [];
    for (let p = PITCH_MAX; p >= PITCH_MIN; p--) pitches.push(p);

    let pitchToRow = new Map();
    pitches.forEach((p, i) => pitchToRow.set(p, i));

    let nextNoteId = 1;
    // =========================
    // Key / Scale (í‘œì‹œ + ì½”ë“œ ì—°ì£¼)
    // =========================
    let currentKeyRoot = 0; // 0=C
    let currentScaleType = "major";

    // ì½”ë“œ ì°ê¸°/ì…ë ¥ ê¸¸ì´(16ë¶„ìŒí‘œ ë‹¨ìœ„): 4=1/4, 2=1/8, 1=1/16
    let insertLen = 1;

    const SCALE_MAJOR = [0, 2, 4, 5, 7, 9, 11];
    const SCALE_MINOR = [0, 2, 3, 5, 7, 8, 10]; // natural minor

    function getScaleSemis() {
      return (currentScaleType === "minor") ? SCALE_MINOR : SCALE_MAJOR;
    }

    function getScalePitchClassSet() {
      const base = getScaleSemis();
      return new Set(base.map(x => (x + currentKeyRoot) % 12));
    }

    // =========================
// Chord presets (v51)
// =========================
const CHORD_PRESETS = {
  p1: ["I","iii","IV","V"],   // C Em F G
  p2: ["I","vi","IV","V"],    // C Am F G
  p3: ["I","V","vi","IV"],    // C G Am F
};

// Roman triads -> scale degrees (major/minor)
const ROMAN_DEGREES_MAJOR = { "I":[1,3,5], "ii":[2,4,6], "iii":[3,5,7], "IV":[4,6,1], "V":[5,7,2], "vi":[6,1,3], "viiÂ°":[7,2,4] };
const ROMAN_DEGREES_MINOR = { "i":[1,3,5], "iiÂ°":[2,4,6], "III":[3,5,7], "iv":[4,6,1], "v":[5,7,2], "VI":[6,1,3], "VII":[7,2,4] };

let activeChordPresetId = "";   // "", "p1" | "p2" | "p3"
let autoChordEnabled = false;

function getScalePcsArray() {
  const base = getScaleSemis(); // semitones from tonic for current scale
  return base.map(x => (x + currentKeyRoot) % 12); // 7 pitch classes
}

function getChordTonePcSetForBar(barIndex1Based) {
  if (!activeChordPresetId) return null;
  const preset = CHORD_PRESETS[activeChordPresetId];
  if (!preset) return null;

  const roman = preset[(barIndex1Based - 1) % 4];
  const scalePcs = getScalePcsArray();
  const degMap = (currentScaleType === "minor") ? ROMAN_DEGREES_MINOR : ROMAN_DEGREES_MAJOR;
  const degrees = degMap[roman] || degMap[roman.replace("Â°","")] || null;
  if (!degrees) return null;

  const pcs = new Set();
  degrees.forEach(deg => {
    const idx = (deg - 1) % 7;
    pcs.add(scalePcs[idx]);
  });
  return pcs;
}

function applyPresetToGridCells() {
  document.body.classList.toggle("presetActive", !!activeChordPresetId);

  const cells = gridEl.querySelectorAll(".cell");
  cells.forEach(cell => {
    const bar = Number(cell.dataset.bar);
    const pitch = Number(cell.dataset.pitch);
    const pc = ((pitch % 12) + 12) % 12;

    const inScale = isInCurrentKey(pitch);
    cell.classList.toggle("scale", inScale);

    if (!activeChordPresetId) {
      cell.classList.remove("chord");
      return;
    }
    const chordPcs = getChordTonePcSetForBar(bar);
    const inChord = chordPcs ? chordPcs.has(pc) : false;
    cell.classList.toggle("chord", inChord);
  });
}

function isInCurrentKey(midi) {
      return getScalePitchClassSet().has(((midi % 12) + 12) % 12);
    }

    function updateKeyHighlights() {
      // ë¼ë²¨: pitches ìˆœì„œì™€ labelsEl ìì‹ ìˆœì„œê°€ ê°™ìŒ
      const labelEls = labelsEl.querySelectorAll(".label");
      for (let i = 0; i < labelEls.length; i++) {
        const pitch = pitches[i];
        labelEls[i].classList.toggle("outKey", !isInCurrentKey(pitch));
      }

      // ì…€
      const cells = gridEl.querySelectorAll(".cell");
      cells.forEach(c => {
        const pitch = Number(c.dataset.pitch);
        c.classList.toggle("outKey", !isInCurrentKey(pitch));
      });
    }

    function applyKey() {
      const rootEl = document.getElementById("keyRoot");
      const scaleEl = document.getElementById("scaleType");
      if (rootEl) currentKeyRoot = Number(rootEl.value);
      if (scaleEl) currentScaleType = scaleEl.value;
      updateKeyHighlights();
    }



    

    function initInsertLenButtons() {
      const seg = document.getElementById("insertLenSeg");
      if (!seg) return;
      const btns = Array.from(seg.querySelectorAll("button[data-len]"));
      const setActive = (len) => {
        insertLen = len;
        lastInsertStep = len;
        btns.forEach(b => b.classList.toggle("active", Number(b.dataset.len) === len));
      };
      btns.forEach(b => b.addEventListener("click", () => setActive(Number(b.dataset.len))));
      const active = btns.find(b => b.classList.contains("active"));
      setActive(active ? Number(active.dataset.len) : 1);
    }
// =========================
    // ì‹œê°„ ë³€í™˜ (ë§ˆë””/16ë¶„ -> ì´ˆ)
    // =========================
    function positionToSeconds(bar, beat16, bpm) {
      const sixteenth = (60 / bpm) / SUBDIV;
      return (bar - 1) * beatsPerBar * SUBDIV * sixteenth
           + (beat16 - 1) * sixteenth;
    }
    function lengthToSeconds(length16, bpm) {
      return length16 * (60 / bpm) / SUBDIV;
    }

    // =========================
    // ìœ„ì¹˜ ë³€í™˜
    // =========================
    function posToCol(bar, beat16) {
      return (bar - 1) * beatsPerBar * SUBDIV + (beat16 - 1);
    }
    function findNoteIndexAtStart(trackNotes, bar, beat16, pitch) {
      return trackNotes.findIndex(n => n.bar === bar && n.beat === beat16 && n.pitch === pitch);
    }

    // í´ë¦­í•œ col(0-base)ì´ ê¸°ì¡´ ë…¸íŠ¸ì˜ ë²”ìœ„(start~end)ì— í¬í•¨ë˜ëŠ”ì§€ ì°¾ê¸°
    function findNoteIndexCovering(trackNotes, col, pitch) {
      return trackNotes.findIndex(n => {
        if (n.pitch !== pitch) return false;
        const startCol = posToCol(n.bar, n.beat);
        const endCol = startCol + Math.max(1, n.length) - 1;
        return col >= startCol && col <= endCol;
    });
  }


    // =========================
    // UI ì—˜ë¦¬ë¨¼íŠ¸
    // =========================
    const labelsEl = document.getElementById("labels");
    const gridWrapEl = document.getElementById("gridWrap");

// =========================
// í”Œë ˆì´í—¤ë“œ(í¬ì§€ì…˜ ë°”) / ì»¤ì„œ
// =========================
const playheadEl = document.getElementById("playhead");
let cursorCol = 0;
    let stopArmed = false; // press Stop twice to reset to start // 0..totalCols-1 (16ë¶„ìŒí‘œ ì¹¸)
let rafId = null;

function colToTransportPos(col) {
  const measures = Math.floor(col / 16);
  const beat16 = col % 16;
  const quarters = Math.floor(beat16 / 4);
  const six = beat16 % 4;
  return `${measures}:${quarters}:${six}`;
      if (activeChordPresetId) applyPresetToGridCells();
    }


function noteToTransportPos(note) {
  const measures = note.bar - 1;
  const quarters = Math.floor((note.beat - 1) / 4);
  const six = (note.beat - 1) % 4;
  return `${measures}:${quarters}:${six}`;
}

function updatePlayheadVisual(col) {
  if (!playheadEl) return;
  playheadEl.style.left = `${col * CELL}px`;
  playheadEl.classList.remove("hidden");
}

function advanceCursorAfterInsert() {
  const step = lastInsertStep || 1; // step is in 16th-cells (1=1/16, 2=1/8, 4=1/4)
  cursorCol = Math.min(cursorCol + step, totalCols - 1);
  updatePlayheadVisual(cursorCol);

  // keep cursor visible
  const wrap = document.querySelector(".gridwrap");
  if (wrap) {
    const x = cursorCol * CELL; // CELL is px per column
    if (x < wrap.scrollLeft + 20) wrap.scrollLeft = Math.max(0, x - 20);
    if (x > wrap.scrollLeft + wrap.clientWidth - 40) wrap.scrollLeft = x - (wrap.clientWidth - 40);
  }
}


function setCursorCol(col) {
      stopArmed = false;
  cursorCol = Math.max(0, Math.min(totalCols - 1, col));
  if (Tone.Transport.state !== "started") updatePlayheadVisual(cursorCol);
}

function startPlayheadLoop() {
  if (rafId) cancelAnimationFrame(rafId);
  playheadEl.classList.remove("hidden");

  const tick = () => {
      if (Tone.Transport.state === "started") {
        // Transport.position = "measures:quarters:sixteenths" (0-based measures)
        const pos = Tone.Transport.position.toString();
        const parts = pos.split(":").map(x => Number(x));
        const m = (Number.isFinite(parts[0]) ? parts[0] : 0);
        const q = (Number.isFinite(parts[1]) ? parts[1] : 0);
        const s = (Number.isFinite(parts[2]) ? parts[2] : 0);
        const col = Math.max(0, Math.min(totalCols - 1, m * 16 + q * 4 + s));
        updatePlayheadVisual(col);
      }
      rafId = requestAnimationFrame(tick);
    };
  rafId = requestAnimationFrame(tick);
}

function stopPlayheadLoop() {
  if (rafId) cancelAnimationFrame(rafId);
  rafId = null;
  updatePlayheadVisual(cursorCol);
}

// íƒ€ì„ë¼ì¸ í´ë¦­ìœ¼ë¡œ ì»¤ì„œ ìœ„ì¹˜ ì§€ì •
document.getElementById("timeline").addEventListener("click", (e) => {
  const t = e.target;
  if (!t || !t.classList || !t.classList.contains("tick")) return;
  const col = Number(t.dataset.col);
  if (!Number.isFinite(col)) return;
  setCursorCol(col);
});

    const gridEl = document.getElementById("grid");

// Prevent iOS/Safari long-press text selection & context menu on the grid
gridEl.addEventListener("contextmenu", (e) => e.preventDefault());
gridEl.addEventListener("selectstart", (e) => e.preventDefault());
    const notesLayerEl = document.getElementById("notesLayer");
    const timelineEl = document.getElementById("timeline");
    const bpmEl = document.getElementById("bpm");

    function midiToName(m) {
      const names = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
      const name = names[m % 12];
      const oct = Math.floor(m / 12) - 1;
      return `${name}${oct}`;
    }



// ===== Range presets (MIDI) =====
const RANGE_PRESETS = {
  full:  { min: 48, max: 71 }, // C3..B4 (2 oct)
  male:  { min: 52, max: 69 }, // E3..A4 (~1.5 oct)
  female:{ min: 55, max: 72 }  // G3..C5 (~1.5 oct)
};

function buildPitchData(minMidi, maxMidi){
  pitches = [];
  for (let p=maxMidi; p>=minMidi; p--) pitches.push(p);
  pitchToRow = new Map();
  pitches.forEach((p,i)=>pitchToRow.set(p,i));
}

function setRangePreset(key){
  const preset = RANGE_PRESETS[key] || RANGE_PRESETS.full;
  buildPitchData(preset.min, preset.max);
  buildGrid();
  renderNotes();
  updatePlayheadVisual(cursorCol);
}


function lockGridScroll() {
  const wrap = document.querySelector(".gridwrap");
  if (!wrap) return;
  wrap.dataset.prevOverflowX = wrap.style.overflowX || "";
  wrap.dataset.prevTouchAction = wrap.style.touchAction || "";
  wrap.style.overflowX = "hidden";
  wrap.style.touchAction = "none";
}
function unlockGridScroll() {
  const wrap = document.querySelector(".gridwrap");
  if (!wrap) return;
  wrap.style.overflowX = wrap.dataset.prevOverflowX || "auto";
  wrap.style.touchAction = wrap.dataset.prevTouchAction || "pan-x";
}
    function buildTimeline() {
      document.getElementById("timeline").style.gridTemplateColumns = `repeat(${totalCols}, ${CELL}px)`;
      document.getElementById("timeline").innerHTML = "";

      for (let col = 0; col < totalCols; col++) {
        const bar = Math.floor(col / (beatsPerBar * SUBDIV)) + 1;
        const beat16 = (col % (beatsPerBar * SUBDIV)) + 1;

        const tick = document.createElement("div");
        tick.className = "tick";
        tick.dataset.col = col;

        // 1) ë§ˆë”” ì²« ì¹¸ì—ëŠ” ë§ˆë”” ë²ˆí˜¸
        // 2) ê·¸ ì™¸ì—ëŠ” ë°•(1~4)ë§Œ í‘œì‹œ (16ë¶„ì€ ë„ˆë¬´ ë³µì¡í•˜ë‹ˆê¹Œ)
        if (beat16 === 1) {
          tick.classList.add("bar");
          tick.textContent = `${bar}`;
        } else if ((beat16 - 1) % SUBDIV === 0) {
          tick.textContent = `${((beat16 - 1) / SUBDIV) + 1}`; // 2,3,4 ë°•
        } else {
          tick.textContent = "";
        }

        document.getElementById("timeline").appendChild(tick);
      }
    }

    function buildGrid() {
      // ë¼ë²¨
      labelsEl.style.gridTemplateRows = `repeat(${pitches.length}, ${CELL}px)`;
      labelsEl.innerHTML = "";
      pitches.forEach(p => {
        const div = document.createElement("div");
        div.className = "label";
        if (!isInCurrentKey(p)) div.classList.add("outKey");
        div.textContent = midiToName(p);
        labelsEl.appendChild(div);
      });

      // ê·¸ë¦¬ë“œ
      gridEl.style.gridTemplateColumns = `repeat(${totalCols}, ${CELL}px)`;
      gridEl.style.gridTemplateRows = `repeat(${pitches.length}, ${CELL}px)`;
      gridEl.innerHTML = "";

      // ë˜í¼ í¬ê¸°
      const width = totalCols * CELL + 2;
      const height = pitches.length * CELL + 2;
      gridWrapEl.style.width = `${width}px`;
      gridWrapEl.style.height = `${height}px`;

      for (let row = 0; row < pitches.length; row++) {
        for (let col = 0; col < totalCols; col++) {
          const cell = document.createElement("div");
          cell.className = "cell";

          const bar = Math.floor(col / (beatsPerBar * SUBDIV)) + 1;
          const beat16 = (col % (beatsPerBar * SUBDIV)) + 1;
          const pitch = pitches[row];

          if (!isInCurrentKey(pitch)) cell.classList.add("outKey");

          cell.dataset.bar = String(bar);
          cell.dataset.beat = String(beat16);
          cell.dataset.pitch = String(pitch);

          // ë§ˆë””/ë°• ê²½ê³„ í‘œì‹œ
          if (beat16 === 1) cell.classList.add("barline");
          if ((beat16 - 1) % SUBDIV === 0) cell.classList.add("beatline");

          gridEl.appendChild(cell);
        }
      }
    }

    // =========================
    // ë…¸íŠ¸ ë Œë”(ë¸”ë¡)
    // =========================
    function renderNotes(editingId = null) {
      notesLayerEl.innerHTML = "";

      const notes = project.tracks[0].notes;
      for (const n of notes) {
        const row = pitchToRow.get(n.pitch);
        if (row === undefined) continue;

        const startCol = posToCol(n.bar, n.beat);
        const length = Math.max(1, n.length);
        const endCol = Math.min(totalCols - 1, startCol + length - 1);

        const left = startCol * CELL + 1;
        const top = row * CELL + 1;
        const width = (endCol - startCol + 1) * CELL - 2;

        const div = document.createElement("div");
        div.className = "note";
        if (editingId && n.id === editingId) {
          div.classList.add("editing");
          if (dragState && dragState.mode === "move") div.classList.add("moving");
        }

        div.style.left = `${left}px`;
        div.style.top = `${top}px`;
        div.style.width = `${Math.max(6, width)}px`;

        notesLayerEl.appendChild(div);
      }
    }

    // =========================
    // Undo
    // =========================
    const history = [];
    const HISTORY_LIMIT = 50;

    function snapshot() {
      return JSON.parse(JSON.stringify(project.tracks[0].notes));
    }
    function pushHistory() {
      history.push(snapshot());
      if (history.length > HISTORY_LIMIT) history.shift();
    }
    function undo() {
      if (history.length === 0) return;
      project.tracks[0].notes = history.pop();
      renderNotes();
    }
    document.addEventListener("keydown", (e) => {
      const z = e.key.toLowerCase() === "z";
      if (z && (e.metaKey || e.ctrlKey)) {
        e.preventDefault();
        undo();
      }
    });

    // =========================
    // ì…ë ¥: í´ë¦­ ì‚­ì œ + ë“œë˜ê·¸ ê¸¸ì´
    // =========================
    let dragState = null;



// =========================
// Gesture edit (tap delete / long-press move / immediate drag resize)
// =========================
const TAP_MAX_MS = 250;
const LONGPRESS_MS = 600;
const MOVE_THRESHOLD = 10; // px

let pressTimer = null;
let pressStartTime = 0;
let pressStartX = 0;
let pressStartY = 0;
let pendingNoteIndex = null;
let pendingDidHistory = false;

function clearPressTimer() {
  if (pressTimer) {
    clearTimeout(pressTimer);
    pressTimer = null;
  }
}
    
gridEl.addEventListener("pointerdown", (e) => {
  primeOnce(); // don't await (must stay in user gesture call stack)

      if (typeof viewMode !== 'undefined' && viewMode === 'full') return;
  const cell = document.elementFromPoint(e.clientX, e.clientY);
  if (!cell || !cell.classList.contains("cell")) return;

  e.preventDefault();
  
  gridEl.setPointerCapture(e.pointerId);
  lockGridScroll();

  pressStartTime = Date.now();
  pressStartX = e.clientX;
  pressStartY = e.clientY;
  pendingNoteIndex = null;
  pendingDidHistory = false;
  clearPressTimer();

  const bar = Number(cell.dataset.bar);
  const beat16 = Number(cell.dataset.beat);
  const pitch = Number(cell.dataset.pitch);
  const col = posToCol(bar, beat16);

  const notes = project.tracks[0].notes;

  // 1) start-cell index (for legacy behavior)
  const idxStart = findNoteIndexAtStart(notes, bar, beat16, pitch);
  // 2) any-cover index (note body)
  const idxCover = findNoteIndexCovering(notes, col, pitch);

  // --- Existing note: gesture edit ---
  if (idxCover >= 0) {
    pendingNoteIndex = idxCover;

    // Long-press => move mode
    pressTimer = setTimeout(() => {
      if (pendingNoteIndex === null) return;
      const n = notes[pendingNoteIndex];
      if (!n) return;
      if (!pendingDidHistory) { pushHistory(); pendingDidHistory = true; }

      dragState = {
        mode: "move",
        noteIndex: pendingNoteIndex,
        moved: false,
      };
      renderNotes(n.id);
    }, LONGPRESS_MS);

    // Pending state: on quick tap => delete, on early move => resize
    dragState = {
      mode: "pending",
      noteIndex: pendingNoteIndex,
      startCol: posToCol(notes[pendingNoteIndex].bar, notes[pendingNoteIndex].beat),
      startLen: notes[pendingNoteIndex].length
    };
    renderNotes(notes[pendingNoteIndex].id);
    return;
  }

  // --- Empty cell: create (existing behavior) ---
  pushHistory();
  const n = { id: nextNoteId++, bar, beat: beat16, length: 1, pitch };
  notes.push(n);
  
  // ğŸ”Š audition on create
  auditionPitch(pitch);
dragState = { mode: "create", startCol: col, noteIndex: notes.length - 1, moved: false };
  renderNotes(n.id);
});

gridEl.addEventListener("pointermove", (e) => {
  if (!dragState) return;

  // If we are pending on an existing note, decide between resize (early drag) or keep waiting for long-press (move)
  if (dragState.mode === "pending") {
    const dx = Math.abs(e.clientX - pressStartX);
    const dy = Math.abs(e.clientY - pressStartY);
    if (dx > MOVE_THRESHOLD || dy > MOVE_THRESHOLD) {
      clearPressTimer();
      const notes = project.tracks[0].notes;
      const n = notes[dragState.noteIndex];
      if (!n) return;
      if (!pendingDidHistory) { pushHistory(); pendingDidHistory = true; }

      dragState.mode = "resize_existing";
      // fallthrough to apply resize below
    } else {
      return; // still waiting
    }
  }

  // Create-drag (existing)
  if (dragState.mode === "create") {
    const cell = document.elementFromPoint(e.clientX, e.clientY);
    if (!cell || !cell.classList.contains("cell")) return;
    const bar = Number(cell.dataset.bar);
    const beat16 = Number(cell.dataset.beat);
    const col = posToCol(bar, beat16);

    const notes = project.tracks[0].notes;
    const n = notes[dragState.noteIndex];
    if (!n) return;
    const newLen = Math.max(1, (col - dragState.startCol) + 1);
    if (newLen !== n.length) dragState.moved = true;
    n.length = newLen;
    renderNotes(n.id);
    return;
  }

  // Move (after long-press)
  if (dragState.mode === "move") {
    const cell = document.elementFromPoint(e.clientX, e.clientY);
    if (!cell || !cell.classList.contains("cell")) return;
    const bar = Number(cell.dataset.bar);
    const beat16 = Number(cell.dataset.beat);
    const pitch = Number(cell.dataset.pitch);

    const notes = project.tracks[0].notes;
    const n = notes[dragState.noteIndex];
    if (!n) return;


    // mark moved only if something actually changes
    if (n.bar !== bar || n.beat !== beat16 || n.pitch !== pitch) dragState.moved = true;
    n.bar = bar;
    n.beat = beat16;
    n.pitch = pitch;
    renderNotes(n.id);
    return;
  }

  // Resize existing (early drag on a note)
  if (dragState.mode === "resize_existing") {
    const cell = document.elementFromPoint(e.clientX, e.clientY);
    if (!cell || !cell.classList.contains("cell")) return;
    const bar = Number(cell.dataset.bar);
    const beat16 = Number(cell.dataset.beat);
    const col = posToCol(bar, beat16);

    const notes = project.tracks[0].notes;
    const n = notes[dragState.noteIndex];
    if (!n) return;

    const newLen = Math.max(1, (col - dragState.startCol) + 1);
    n.length = newLen;
    renderNotes(n.id);
    return;
  }

  // Legacy resize mode (if any older logic triggers it)
  if (dragState.mode === "resize") {
    const cell = document.elementFromPoint(e.clientX, e.clientY);
    if (!cell || !cell.classList.contains("cell")) return;
    const bar = Number(cell.dataset.bar);
    const beat16 = Number(cell.dataset.beat);
    const col = posToCol(bar, beat16);

    const notes = project.tracks[0].notes;
    const n = notes[dragState.noteIndex];
    if (!n) return;
    const FinalLen = Math.max(1, (col - dragState.startCol) + 1);
    n.length = FinalLen;
    renderNotes(n.id);
  }
});

gridEl.addEventListener("pointerup", () => {
  unlockGridScroll();
  clearPressTimer();

  const elapsed = Date.now() - pressStartTime;

  // Quick tap on existing note => delete
  if (dragState && dragState.mode === "pending" && pendingNoteIndex !== null && elapsed <= TAP_MAX_MS) {
    const notes = project.tracks[0].notes;
    if (!pendingDidHistory) { pushHistory(); pendingDidHistory = true; }
    notes.splice(pendingNoteIndex, 1);
    dragState = null;
    pendingNoteIndex = null;
    renderNotes();
    return;
  }

  // If we just finished moving a note, audition the final pitch once
  if (dragState && dragState.mode === "move") {
    const notes = project.tracks[0].notes;
    const idx = dragState.noteIndex;
    if (typeof idx === "number" && notes[idx] && dragState.moved) {
      auditionPitch(notes[idx].pitch);
    }
  }

  // End create / move / resize
  dragState = null;
  pendingNoteIndex = null;
  renderNotes();
});

gridEl.addEventListener("pointercancel", () => {
  unlockGridScroll();
  clearPressTimer();
  dragState = null;
  pendingNoteIndex = null;
  renderNotes();
});

// On iOS Safari, prevent scroll while drawing/resizing notes
gridEl.addEventListener("touchmove", (e) => {
  if (dragState) e.preventDefault();
}, { passive: false });
    function applyBpm() {
      const v = Number(bpmEl.value);
      if (!Number.isFinite(v) || v < 30 || v > 240) return;
      project.bpm = v;
      Tone.Transport.bpm.value = project.bpm;
    }
    function clearNotes() {
      pushHistory();
      project.tracks[0].notes = [];
      renderNotes();
    }

    // =========================
    // ì¬ìƒ/ì •ì§€
    // =========================
    
    // =========================
    // ì¬ìƒ/ì •ì§€ + ì˜¤ë””ì˜¤(ì‚¬ìš´ë“œí°íŠ¸)
    // =========================
    let pianoInst = null;
    let pianoReadyPromise = null;

    // v70 ì•ˆì •í™”: iOS/ëª¨ë°”ì¼ ì²« ìŒ ì§€ì—° ì™„í™”ìš© í”„ë¼ì„
    let audioPrimed = false;
    let primePromise = null;

    // ì˜¤ë””ì…˜ ì¤‘ë³µ ë°©ì§€(ë¹ ë¥´ê²Œ ì—¬ëŸ¬ ë²ˆ ì°ì„ ë•Œ, ë§ˆì§€ë§‰ ê²ƒë§Œ)
    let auditionSeq = 0;

    Tone.Transport.bpm.value = project.bpm;

    function pitchToMidi(pitch) { return pitch; } // note.pitchëŠ” ì´ë¯¸ MIDI ë²ˆí˜¸

    async function ensurePiano() {
      if (pianoInst) return pianoInst;

      const audioCtx = Tone.getContext().rawContext;
      if (!pianoReadyPromise) {
        // fetch/decode ì‹œì‘ (ì˜¤ë””ì˜¤ ì¬ìƒì€ ì•„ë‹˜)
        pianoReadyPromise = Soundfont.instrument(audioCtx, "acoustic_grand_piano").catch(() => null);
      }
      pianoInst = await pianoReadyPromise;
      return pianoInst;
    }

    function primeOnce() {
      // iOS/Safari: must be resumed inside a user gesture. If it fails, allow retry on next gesture.
      const ctx = (window.Tone && Tone.getContext) ? Tone.getContext().rawContext : null;
      const isRunning = ctx && ctx.state === "running";

      // If already primed AND context still running, we're done.
      if (audioPrimed && isRunning) return primePromise || Promise.resolve();

      // If context is not running, do NOT lock ourselves into "primed" forever.
      if (!isRunning) {
        audioPrimed = false;
      }

      if (!primePromise) {
        primePromise = (async () => {
          try {
            // Try to unlock/resume AudioContext. Must be called from a user gesture to succeed on mobile.
            if (window.Tone && Tone.start) await Tone.start();
          } catch (e) {
            // If unlock fails, clear promise so we can retry on next gesture.
            primePromise = null;
            audioPrimed = false;
            return;
          }

          try {
            const inst = await ensurePiano();
            if (!inst) return;

            const raw = Tone.getContext().rawContext;
            const now = raw.currentTime;

            // Near-silent warmup note to force sample decode.
            inst.play(60, now + 0.01, { duration: 0.05, gain: 0.0001 });
          } catch (e) {}

          audioPrimed = true;

          // If context got suspended again for any reason, allow future retry.
          try {
            const raw = Tone.getContext().rawContext;
            if (raw && raw.state !== "running") audioPrimed = false;
          } catch (e) {}
        })().finally(() => {
          // Allow future prime attempts if we are not running/primed.
          try {
            const raw = Tone.getContext().rawContext;
            if (!audioPrimed || (raw && raw.state !== "running")) {
              primePromise = null;
            }
          } catch (e) {
            primePromise = null;
          }
        });
      }

      return primePromise;
    }


    // =========================
    // ë‹¤ì´ì•„í† ë‹‰ ì½”ë“œ (1~7) ì—°ì£¼
    // =========================
    
function getGridCenterMidi() {
  // pitches ë°°ì—´ì´ ë†’ì€->ë‚®ì€ ìˆœì¼ ìˆ˜ ìˆìœ¼ë‹ˆ ì¤‘ì•™ê°’ ì‚¬ìš©
  const sorted = [...pitches].sort((a,b)=>a-b);
  const mid = sorted[Math.floor(sorted.length / 2)];
  return mid;
}

function shiftChordIntoRange(chord, minP, maxP, target) {
  // chord ì „ì²´ë¥¼ ì˜¥íƒ€ë¸Œ ë‹¨ìœ„ë¡œ ì´ë™ì‹œì¼œ í‰ê· ì´ target ê·¼ì²˜ê°€ ë˜ë„ë¡
  const avg = (arr) => arr.reduce((a,b)=>a+b,0)/arr.length;
  let c = [...chord];

  // 1) í‰ê· ì„ targetì— ê°€ê¹ê²Œ
  for (let i=0; i<8; i++) {
    const a = avg(c);
    if (a > target + 3) c = c.map(n => n - 12);
    else if (a < target - 3) c = c.map(n => n + 12);
    else break;
  }

  // 2) ë²”ìœ„ ë°–ì´ë©´ ë‹¤ì‹œ ë³´ì •
  for (let i=0; i<8; i++) {
    const lo = Math.min(...c);
    const hi = Math.max(...c);
    if (lo < minP) c = c.map(n => n + 12);
    else if (hi > maxP) c = c.map(n => n - 12);
    else break;
  }

  // ë§ˆì§€ë§‰: ê°œë³„ ìŒì´ ì‚´ì§ ë°–ì´ë©´ nearest octaveë¡œ í´ë¨í”„
  c = c.map(n => {
    while (n < minP) n += 12;
    while (n > maxP) n -= 12;
    return n;
  });

  return c;
}
function rootMidiNear(center = 60) {
      // center ê·¼ì²˜ì—ì„œ í˜„ì¬ í‚¤ ë£¨íŠ¸ pitch classì— ë§ëŠ” MIDIë¥¼ ì°¾ëŠ”ë‹¤.
      const pc = currentKeyRoot;
      let m = center;
      while (((m % 12) + 12) % 12 !== pc) m--;
      if (center - m > 6) m += 12;
      return m;
    }

    // degree: 1~7
    
    function getChordCenterMidi() {
      // ê·¸ë¦¬ë“œì˜ ì¤‘ê°„ ìŒì—­ì„ ê¸°ì¤€ìœ¼ë¡œ ì½”ë“œ ë³´ì´ì‹±ì„ ì¡ëŠ”ë‹¤
      if (!Array.isArray(pitches) || pitches.length === 0) return 60;
      return pitches[Math.floor(pitches.length / 2)];
    }

    function transposeIntoRange(midi, minP, maxP) {
      let m = midi;
      while (m < minP) m += 12;
      while (m > maxP) m -= 12;
      return m;
    }

function diatonicTriad(degree, center = 60) {
      const scale = getScaleSemis(); // length 7
      const root = rootMidiNear(center);
      const d0 = degree - 1; // 0~6
      const steps = [0, 2, 4]; // 1-3-5

      return steps.map(step => {
        const idx = d0 + step;
        const oct = Math.floor(idx / 7) * 12;
        const deg = idx % 7;
        return root + scale[deg] + oct;
      });
    }

    
// =========================
// ì½”ë“œ ë³´ì´ì‹±(ìë¦¬ë°”ê¿ˆ) ê°œì„ : ê³µí†µìŒ ìœ ì§€ + ìµœì†Œ ì´ë™
// =========================
function getNotesAtCursor(track, col) {
  const out = [];
  for (const n of track.notes) {
    if (posToCol(n.bar, n.beat) === col) out.push(n.pitch);
  }
  return out.sort((a,b)=>a-b);
}

function pitchClass(n) { return ((n % 12) + 12) % 12; }

function triadPitchClasses(degree) {
  // diatonicTriad ê²°ê³¼ë¥¼ ì´ìš©í•´ pitch class 3ê°œë¥¼ ì–»ëŠ”ë‹¤
  const base = diatonicTriad(degree, getGridCenterMidi());
  const pcs = [];
  for (const n of base) {
    const pc = pitchClass(n);
    if (!pcs.includes(pc)) pcs.push(pc);
  }
  return pcs.slice(0, 3);
}

function generateTriadVoicings(pcs, minP, maxP, targetCenter) {
  // pcs length 3
  const baseOct = Math.floor(targetCenter / 12) * 12;

  // root position near center
  let base = pcs.map(pc => baseOct + pc).sort((a,b)=>a-b);
  // ascending
  for (let i=1; i<base.length; i++) while (base[i] < base[i-1]) base[i] += 12;

  const cands = [];

  const add = (arr) => {
    let c = arr.slice().sort((a,b)=>a-b);
    c = shiftChordIntoRange(c, minP, maxP, targetCenter);
    if (c.every(n => n >= minP && n <= maxP)) cands.push(c);
  };

  add(base);
  add([base[1], base[2], base[0] + 12]); // 1st inv
  add([base[2], base[0] + 12, base[1] + 12]); // 2nd inv

  // octave variants
  const seen = new Set();
  const expanded = [];
  for (const c of cands) {
    for (const k of [-24, -12, 0, 12, 24]) {
      const shifted = c.map(n => n + k);
      const fixed = shiftChordIntoRange(shifted, minP, maxP, targetCenter);
      const key = fixed.join(",");
      if (seen.has(key)) continue;
      seen.add(key);
      if (fixed.every(n => n >= minP && n <= maxP)) expanded.push(fixed);
    }
  }
  return expanded.length ? expanded : cands;
}

function scoreAgainstReference(ref, cand) {
  // ref, cand sorted length 3
  let s = 0;
  for (let i=0; i<3; i++) s += Math.abs(ref[i] - cand[i]);
  return s;
}

function commonToneBonus(ref, cand) {
  // common pitch classes bonus (lower is better)
  const refPcs = new Set(ref.map(pitchClass));
  const candPcs = new Set(cand.map(pitchClass));
  let common = 0;
  for (const pc of candPcs) if (refPcs.has(pc)) common++;
  if (common === 3) return -60;
  if (common === 2) return -30;
  if (common === 1) return -10;
  return 0;
}

function chooseVoicingWithVoiceLeading(degree, track, col) {
  const minP = Math.min(...pitches);
  const maxP = Math.max(...pitches);
  const center = getGridCenterMidi();

  const pcs = triadPitchClasses(degree);
  if (pcs.length < 3) {
    let chord = diatonicTriad(degree, center);
    return shiftChordIntoRange(chord, minP, maxP, center);
  }

  const candidates = generateTriadVoicings(pcs, minP, maxP, center);

  const existing = getNotesAtCursor(track, col);
  if (existing.length >= 3) {
    // choose a 3-note window closest to center
    let ref = existing.slice(0, 3);
    let bestDist = Infinity;
    for (let i=0; i<=existing.length-3; i++) {
      const w = existing.slice(i, i+3);
      const avg = (w[0] + w[1] + w[2]) / 3;
      const dist = Math.abs(avg - center);
      if (dist < bestDist) { bestDist = dist; ref = w; }
    }

    let best = candidates[0] || diatonicTriad(degree, center);
    let bestScore = Infinity;
    for (const c of candidates) {
      const score = scoreAgainstReference(ref, c) + commonToneBonus(ref, c);
      if (score < bestScore) { bestScore = score; best = c; }
    }
    return best;
  }

  // no reference: pick closest to center
  let best = candidates[0] || diatonicTriad(degree, center);
  let bestScore = Infinity;
  for (const c of candidates) {
    const avg = (c[0] + c[1] + c[2]) / 3;
    const score = Math.abs(avg - center);
    if (score < bestScore) { bestScore = score; best = c; }
  }
  return best;
}

async function playChord(degree) {
      if (typeof viewMode !== "undefined" && viewMode === "full") return;
  const inst = await ensurePiano();
  const audioCtx = Tone.getContext().rawContext;
  const now = audioCtx.currentTime;

  const track = project.tracks[0];
  const minP = Math.min(...pitches);
  const maxP = Math.max(...pitches);

  // ë³´ì´ì‹±(ìë¦¬ë°”ê¿ˆ) ì„ íƒ: ê³µí†µìŒ ìœ ì§€ + ìµœì†Œ ì´ë™
  let chord = chooseVoicingWithVoiceLeading(degree, track, cursorCol);

  // (ì•ˆì „) chord ë‚´ë¶€ ì¤‘ë³µ ì œê±° + ë²”ìœ„ í•„í„°
  chord = Array.from(new Set(chord)).filter(n => n >= minP && n <= maxP);

  const dur = 0.9;

  // í•­ìƒ ì˜¤ë””ì…˜(ë¯¸ë¦¬ë“£ê¸°)
  for (const p of chord) {
    inst.play(p, now, { duration: dur, gain: 0.9 });
  }

  // ì •ì§€ ìƒíƒœì¼ ë•Œë§Œ: ì»¤ì„œ ìœ„ì¹˜ì— "ì°ê¸°"
  if (Tone.Transport.state !== "started") {
    const chordLen = insertLen;

  // remember current insert length for playhead advance
  lastInsertStep = insertLen;

    const bar = Math.floor(cursorCol / 16) + 1;
    const beat = (cursorCol % 16) + 1;

    pushHistory();

    for (const p of chord) {
      // ì¤‘ë³µ ë°©ì§€: ê°™ì€ ì»¤ì„œ ìœ„ì¹˜(ê°™ì€ col) + ê°™ì€ pitchê°€ ì´ë¯¸ ìˆìœ¼ë©´ ì¶”ê°€í•˜ì§€ ì•ŠìŒ
      const exists = track.notes.some(n =>
        posToCol(n.bar, n.beat) === cursorCol && n.pitch === p
      );
      if (exists) continue;

      track.notes.push({
        id: nextNoteId++,
        bar,
        beat,
        length: chordLen,
        pitch: p
      });
    }

    renderNotes();
      advanceCursorAfterInsert();
  }
}

document.addEventListener("keydown", (e) => {
      const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
      if (tag === "input" || tag === "select" || tag === "textarea") return;

      if (e.key >= "1" && e.key <= "7") {
        e.preventDefault();
        playChord(Number(e.key));
      }
    });
    

function stop() {
  const running = (Tone.Transport.state === "started");
  if (running) {
    // 1st press while playing: stop
    stopOnceInternal();
    stopArmed = true;
    return;
  }

  // If already stopped: always jump to start of current view
  // If already stopped: always jump to start of current view
  setCursorCol(0);
const wrap = document.querySelector(".gridwrap");
  if (wrap) wrap.scrollLeft = 0;
  stopArmed = false;
}


function stopOnceInternal() {
  if (Tone.Transport.state === "started") {
    const bpm = Tone.Transport.bpm.value;
    const secPer16 = (60 / bpm) / 4;
    const col = Math.max(0, Math.min(totalCols - 1, Math.floor(Tone.Transport.seconds / secPer16)));
    setCursorCol(col);
  }
  Tone.Transport.stop();
  Tone.Transport.cancel();
  stopPlayheadLoop();
}

    // =========================
    // MIDI ë‚´ë³´ë‚´ê¸°
    // =========================
    function exportMidi() {
      const midi = new Midi();
      midi.header.setTempo(project.bpm);

      project.tracks.forEach(trackData => {
        const midiTrack = midi.addTrack();
        midiTrack.name = trackData.name;

        trackData.notes.forEach(note => {
          midiTrack.addNote({
            midi: note.pitch,
            time: positionToSeconds(note.bar, note.beat, project.bpm),
            duration: lengthToSeconds(note.length, project.bpm),
            velocity: 0.8
          });
        });
      });

      const blob = new Blob([midi.toArray()], { type: "audio/midi" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "my_web_daw.mid";
      a.click();
      URL.revokeObjectURL(url);
    }

    // =========================
    // ì´ˆê¸°í™”
    // =========================
    buildTimeline();
    buildGrid();
    renderNotes();
    applyKey();
  

// Range UI
const rangeSel = document.getElementById("rangeSel");
if (rangeSel) {
  rangeSel.addEventListener("change", () => setRangePreset(rangeSel.value));
  setRangePreset(rangeSel.value); // initial
}
    initInsertLenButtons();
// Chord preset UI (inactive until user picks one)
const chordPresetSel = document.getElementById("chordPresetSel");
const autoChordToggle = document.getElementById("autoChordToggle");

if (chordPresetSel) {
  chordPresetSel.value = activeChordPresetId || "";
  chordPresetSel.addEventListener("change", () => {
    activeChordPresetId = chordPresetSel.value || "";
    applyPresetToGridCells();
  });
}
if (autoChordToggle) {
  autoChordToggle.checked = !!autoChordEnabled;
  autoChordToggle.addEventListener("change", () => {
    autoChordEnabled = !!autoChordToggle.checked;
  });
}
// Track UI (boot)
bindTrackUI();
updateTrackUI();


// Warm up instrument loading on the very first user gesture
document.addEventListener('pointerdown', () => { try { ensurePiano().catch(()=>{}); } catch(e) {} }, { once: true, passive: true });
document.addEventListener('touchstart', () => { try { ensurePiano().catch(()=>{}); } catch(e) {} }, { once: true, passive: true });
setCursorCol(0);
    updatePlayheadVisual(0);
    
</script>
</body>
</html>