<!DOCTYPE html>
<html>
<head>
  
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<meta charset="utf-8" />
  <title>My Web DAW v103</title>
  <style>
    body { font-family: system-ui, -apple-system, sans-serif; margin: 16px; }
    h1 { margin: 0 0 6px; }
    .legend { margin: 8px 0 12px; color: #555; font-size: 14px; }

    .toolbar {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 12px;
    }
    .toolbar input { width: 80px; }

    .topbar, .pianoroll {
      display: grid;
      grid-template-columns: 70px 1fr;
      gap: 8px;
      align-items: start;
      max-width: 980px;
    }
    .topbar { margin-bottom: 6px; }

    .labels {
      display: grid;
      gap: 0;              /* ✅ 줄간격 없애서 그리드랑 일치 */
      padding-top: 1px;    /* ✅ grid의 바깥 border(1px)만큼 맞춤 */
      border: 1px solid #ddd;
      border-right: none; /* 라벨-그리드 사이 중복 선 방지 */
      border-radius: 4px 0 0 4px;
      overflow: hidden;
    }

    .label {
      height: 22px;
      box-sizing: border-box;             /* ✅ border가 height 안에 포함되게 */
      border-bottom: 1px solid #e6e6e6;   /* ✅ grid cell과 같은 가로 줄 */
      border-radius: 0;                   /* ✅ 줄 정렬이 더 또렷해짐(원하면 다시 4px 줘도 됨) */
    }


    /* 타임라인 */
    .timeline { display: grid; font-size: 12px; color: #333; }
    .tick {
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f8f8f8;
      border: 1px solid #e6e6e6;
      border-left: none;
    }
    .tick:first-child { border-left: 1px solid #e6e6e6; }
    .tick.bar { font-weight: 600; background: #f1f1f1; }

    /* 그리드 + 노트 오버레이 */
    .gridWrap {
      position: relative;
      width: fit-content;
      touch-action: none;
    }
    .grid {
      display: grid;
      border: 1px solid #ddd;
      background: #fff;
    }
    .cell {
      width: 22px;
      height: 22px;
      border-right: 1px solid #e6e6e6;
      border-bottom: 1px solid #e6e6e6;
      cursor: pointer;
      background: transparent;
      user-select: none;
    }
    /* 마디 시작 (굵은 선) */
    .cell.barline { border-left: 2px solid rgba(0,0,0,0.14); }
    /* 박 시작 (연한 선) */
    .cell.beatline { box-shadow: inset 1px 0 0 rgba(0,0,0,0.08); }

    /* 노트 레이어 */
    .notesLayer {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }
    .note {
      position: absolute;
      height: 22px;
      border-radius: 4px;
      background: #4a90e2;
      box-shadow: 0 0 0 1px rgba(0,0,0,0.08) inset;
    }
    .note.editing {
      box-shadow:
        0 0 0 2px rgba(0,0,0,0.25) inset,
        0 0 0 1px rgba(0,0,0,0.10);
    }

    button:focus { outline: none; }
  
    .cell.outKey { background: #f2f2f2; }
    .label.outKey { color: #999; background: #fafafa; }

  /* 플레이헤드(포지션 바) */
  .playhead {
    position: absolute;
    top: 0;
    bottom: 0;
    width: 2px;
    background: rgba(220, 0, 0, 0.85);
    pointer-events: none;
    transform: translateX(-1px);
  }
  .playhead.hidden { display: none; }

    /* Insert length buttons */
    .seg {
      display: inline-flex;
      border: 1px solid #ddd;
      border-radius: 10px;
      overflow: hidden;
      vertical-align: middle;
    }
    .seg button {
      border: 0;
      padding: 6px 10px;
      background: #fff;
      cursor: pointer;
      font-size: 13px;
      line-height: 1;
    }
    .seg button + button { border-left: 1px solid #ddd; }
    .seg button.active { background: #111; color: #fff; }

  
/* =========================
   Mobile / Responsive
   ========================= */
:root{
  --cellW: 22px;
  --cellH: 18px;
  --labelW: 70px;
  --playheadW: 2px;
}
.topbar, .pianoroll{ max-width: 100%; width: 100%; }
.pianoroll{ grid-template-columns: var(--labelW) minmax(0, 1fr); }
.gridwrap{
  overflow-x: auto;
  overflow-y: hidden;
  -webkit-overflow-scrolling: touch;
  touch-action: pan-x; /* allow horizontal scroll by default */
  border-radius: 10px;
}
.grid{ min-width: calc(var(--cellW) * 64); }
.cell{ width: var(--cellW); height: var(--cellH); }
.note{ height: calc(var(--cellH) - 2px); }
.playhead{ width: var(--playheadW) !important; }

.toolbar button, .toolbar select, .toolbar input{ min-height: 36px; font-size: 14px; }

@media (max-width: 520px){
  :root{ --cellW: 22px; --cellH: 20px; --labelW: 58px; --playheadW: 2px; }
  body{ margin: 10px; }
  h1{ font-size: 18px; }
  .legend{ font-size: 12px; }
  .toolbar button, .toolbar select, .toolbar input{ min-height: 42px; font-size: 16px; }
  .toolbar input{ width: 90px; }
}
  
/* Prevent iOS long-press text selection/callout on the piano roll */
.pianoroll, .labels, .gridwrap, .grid, .cell, .note, .ruler, .rulerCell {
  -webkit-user-select: none;
  user-select: none;
  -webkit-touch-callout: none;
}
  
/* Editing state outline colors */
.note.editing { outline: 2px solid #111; }
.note.editing.moving { outline: 2px solid #d00; }
  
  .partheader {
    max-width: 980px;
    padding: 10px;
    margin-bottom: 6px;
    border-radius: 6px;
    color: #fff;
    font-weight: 600;
    font-size: 14px;
  }
  /* === Chord Track (v85) === */
  .chordtrack {
    max-width: 980px;
    display: grid;
    grid-template-columns: repeat(8, 1fr); /* 4 bars * half-bar */
    gap: 6px;
    margin: 8px 0 10px;
  }
  .chordslot {
    border: 1px solid rgba(0,0,0,0.15);
    background: rgba(59,130,246,0.10);
    border-radius: 8px;
    padding: 8px 6px;
    min-height: 34px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    font-size: 12px;
    color: rgba(0,0,0,0.82);
    user-select: none;
  }
  .chordslot.empty {
    background: rgba(0,0,0,0.04);
    color: rgba(0,0,0,0.35);
    font-weight: 600;
  }
  .chordslot .rn { margin-right: 6px; }
  .chordslot .cn { opacity: 0.85; font-weight: 700; }

  .chordselect{
    width: 100%;
    height: 34px;
    border: none;
    outline: none;
    background: transparent;
    font: inherit;
    font-weight: 800;
    font-size: 12px;
    text-align: center;
    text-align-last: center;
    padding: 0 6px;
    cursor: pointer;
  }
  .chordselect option{ font-weight: 700; }


    .readonly #grid, .readonly #notesLayer { pointer-events: none; }
    .readonlyHint { font-size: 12px; color:#666; margin:6px 0 0; }
:root{
  --bg-scale: #d9d9d9;     /* in key, not chord tone */
  --bg-nonscale: #111111;  /* not in key (strongly off) */
  --bg-chord: #ffffff;     /* chord tone */
}
body.presetActive .cell { background: var(--bg-nonscale); }
body.presetActive .cell.scale { background: var(--bg-scale); }
body.presetActive .cell.chord { background: var(--bg-chord); }

    .trackbar{display:flex;gap:6px;align-items:center;flex-wrap:wrap;margin:6px 0 10px}
    .trackbar .tbtn{border:1px solid #444;background:#1f1f1f;color:#eee;padding:6px 10px;border-radius:10px;font-size:14px;cursor:pointer}
    .trackbar .tbtn.active{border-color:#fff;box-shadow:0 0 0 2px rgba(255,255,255,.15) inset}
    .trackbar .pill{display:inline-flex;align-items:center;gap:6px;margin-left:6px;font-size:12px;color:#bbb}
    .dot{width:10px;height:10px;border-radius:50%;display:inline-block}

    /* --- Start Overlay (audio unlock) --- */
    body.needs-start { overflow: hidden; }
    .startOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.72);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 9999;
    }
    .startOverlay.hidden { display: none; }
    .startCard{
      width: min(420px, 100%);
      background: #111;
      color: #fff;
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 14px;
      padding: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      text-align: center;
    }
    .startTitle{ font-size: 20px; font-weight: 700; margin-bottom: 6px; }
    .startDesc{ font-size: 14px; color: rgba(255,255,255,0.85); line-height: 1.35; margin: 0 0 12px; }
    .startBtn{ font-size: 16px; padding: 10px 14px; min-width: 140px; }
    .startMsg{ margin-top: 10px; font-size: 12px; color: rgba(255,255,255,0.75); min-height: 1.2em; }
  </style>


</head>

<body class="needs-start">
  <div id="startOverlay" class="startOverlay" role="dialog" aria-modal="true" aria-label="Start audio">
    <div class="startCard">
      <div class="startTitle">Start</div>
      <div class="startDesc">
        웹 오디오 정책 때문에, <b>처음 한 번</b>은 버튼을 눌러야 소리가 나요.
      </div>
      <button id="startBtn" class="btn primary startBtn">시작!</button>
      <div id="startMsg" class="startMsg"></div>
    </div>
  </div>

  <h1>My Web DAW v103</h1>
  <div class="toolbar">
  <div class="trackbar" id="trackBar">
    <button class="tbtn" data-track="melody" title="Melody (편집 대상)">Melody</button>
    <button class="tbtn" data-track="keys" title="Keys (코드/건반)">Keys</button>
    <button class="tbtn" data-track="bass" title="Bass">Bass</button>
    <button class="tbtn" data-track="drums" title="Drums (드럼 UI는 다음 단계)">Drums</button>
        <button class="tbtn" id="dupDrumBarBtn" title="현재 마디의 드럼을 다음 마디로 복사">Drum: 마디 복사→다음</button>
<span class="pill">Selected: <span class="dot" id="trackDot" style="background:#2b7cff"></span><span id="trackLabel">melody</span></span>
  </div>

    <button onclick="play()">재생</button>
    <button onclick="stop()">정지</button>
    <button onclick="exportMidi()">MIDI로 저장</button>
    <button onclick="undo()">Undo</button>

    <span style="margin-left:10px;">BPM</span>
    <input id="bpm" type="number" min="30" max="240" step="1" value="90" />
    <button onclick="applyBpm()">적용</button>
    <span style="margin-left:10px;">Range</span>
    <select id="rangeSel">
      <option value="full">Full (C3–B4)</option>
      <option value="male" selected>Male (E3–A4)</option>
      <option value="female">Female (G3–C5)</option>
    </select>



    <span style="margin-left:12px;">Key</span>
    <select id="keyRoot" onchange="applyKey()">
      <option value="0" selected>C</option>
      <option value="1">C#</option>
      <option value="2">D</option>
      <option value="3">D#</option>
      <option value="4">E</option>
      <option value="5">F</option>
      <option value="6">F#</option>
      <option value="7">G</option>
      <option value="8">G#</option>
      <option value="9">A</option>
      <option value="10">A#</option>
      <option value="11">B</option>
    </select>
    <select id="scaleType" onchange="applyKey()">
      <option value="major" selected>Major</option>
      <option value="minor">Natural Minor</option>
    </select>

    <span style="margin-left:10px;">Insert Len</span>
    <span class="seg" id="insertLenSeg">
      <button type="button" data-len="4">1/4</button>
      <button type="button" data-len="2">1/8</button>
      <button type="button" data-len="1" class="active">1/16</button>
    </span>

<span style="margin-left:12px;">Chord Preset</span>
<select id="chordPresetSel">
  <option value="">(none)</option>
  <option value="p1">1) I–iii–IV–V (C–Em–F–G)</option>
  <option value="p2">2) I–vi–IV–V (C–Am–F–G)</option>
  <option value="p3">3) I–V–vi–IV (C–G–Am–F)</option>
</select>
<label style="display:inline-flex;align-items:center;gap:6px;margin-left:10px;">
  <input type="checkbox" id="autoChordToggle" />
  Auto Chords
</label>

    <span style="margin-left:12px;">Parts</span>
    <button onclick="setViewMode('full')">Full</button>
    <button onclick="setViewMode('part')">Part</button>
<button onclick="switchPart('verseA1')">Verse A 1/2</button>
<button onclick="switchPart('verseA2')">Verse A 2/2</button>
<button onclick="switchPart('pre1')">Pre 1/2</button>
<button onclick="switchPart('pre2')">Pre 2/2</button>
<button onclick="switchPart('chorus1')">Chorus 1/2</button>
<button onclick="switchPart('chorus2')">Chorus 2/2</button>

<span style="margin-left:12px;">Chords</span>
    <span style="margin-left:16px;">Chord Rhythm</span>
    <select id="chordRhythmSelect" style="height:26px; margin-left:6px;">
      <option value="halfbar">2-beat (half-bar)</option>
      <option value="beat4" selected>4-beat (each beat)</option>
      <option value="arp8">Arp (8th)</option>
    </select>
    <button id="exportWavBtn" style="height:26px; margin-left:10px;">Export WAV</button>


    <button onclick="playChord(1)">I</button>
    <button onclick="playChord(2)">ii</button>
    <button onclick="playChord(3)">iii</button>
    <button onclick="playChord(4)">IV</button>
    <button onclick="playChord(5)">V</button>
    <button onclick="playChord(6)">vi</button>
    <button onclick="playChord(7)">vii°</button>


    <button onclick="clearNotes()" style="margin-left:auto;">노트 전체 삭제</button>
  
</div>

  <div class="legend">
    16분 해상도(1박=4칸) · 4마디 · 클릭=생성(16분 1칸) · 드래그=길이 · 시작칸 클릭=삭제 · Cmd/Ctrl+Z=Undo
  </div>

  <div class="partheader" id="partHeader"></div>
  <div class="chordtrack" id="chordTrack"></div>
<div class="topbar">
    <div></div>
    <div id="timeline" class="timeline"></div>
  </div>

  <div class="pianoroll">
    <div id="labels" class="labels"></div>

    <div class="gridWrap" id="gridWrap">
      <div class="gridwrap"><div id="grid" class="grid"></div></div>
      <div id="notesLayer" class="notesLayer"></div>
      <div id="playhead" class="playhead hidden"></div>
    </div>
  </div>

  <script src="https://unpkg.com/tone/build/Tone.js">
// FIRST_GESTURE_AUDIO_PRIME
(function(){
  function onFirstGesture(){
    try { if (typeof primeAudio==='function') primeAudio();
  } catch(e) {}
  }
  document.addEventListener('touchstart', onFirstGesture, { once:true, capture:true, passive:false });
  document.addEventListener('pointerdown', onFirstGesture, { once:true, capture:true, passive:false });
})();

</script>
  <script src="https://unpkg.com/@tonejs/midi/build/Midi.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/soundfont-player@0.12.0/dist/soundfont-player.min.js"></script>

  <script>

    // =========================
    // 설정
    // =========================
    const CELL = 22;
    const SUBDIV = 4; // 1박(4분) = 4칸 = 16분 해상도

    // Chord autoplay rhythm (Stage 4)
    let chordRhythm = "beat4";
    window.addEventListener("DOMContentLoaded", ()=>{
      const sel = document.getElementById("chordRhythmSelect");
      if (sel) {
        chordRhythm = sel.value || chordRhythm;
        sel.addEventListener("change", ()=>{ chordRhythm = sel.value; });
      }
    });

    
    // =========================
    // Export: Record mixdown and download (WAV if supported, else WEBM)
    // =========================
    async function exportAudio() {
      try { await primeAudio(); } catch (e) {}

      // Ensure we're stopped and start from bar 1
      try { stopOnceInternal(); } catch (e) {}
      cursorCol = 0;
      try { updatePlayheadVisual(cursorCol); } catch (e) {}

      const totalCols = HALF_BARS_PER_PART * 8; // 8 cols per half-bar
      const durationSec = lengthToSeconds(totalCols, project.bpm) + 1.0; // + tail

      // Get native AudioContext (Tone)
      const toneCtx = (typeof Tone !== "undefined" && Tone.getContext) ? Tone.getContext() : null;
      const ac = (toneCtx && (toneCtx.rawContext || toneCtx._context || toneCtx.context)) || null;
      // Some Tone builds expose an OfflineAudioContext/BaseAudioContext; avoid brittle instanceof checks.
      if (!ac || typeof ac.createMediaStreamDestination !== "function") {
        alert("내보내기 실패: AudioContext를 찾을 수 없어요. (오디오 시작 버튼을 먼저 눌러주세요)");
        return;
      }
      // Make sure the context is running (required by many browsers)
      try { if (ac.state && ac.state !== "running" && ac.resume) await ac.resume(); } catch (e) {}

      // Create a MediaStream destination for recording
      const streamDest = ac.createMediaStreamDestination();

      // Tap MASTER_NODE into recorder (captures Tone + Soundfont)
      let master;
      try { master = ensureMasterNode(); } catch (e) { master = null; }
      if (!master) {
        alert("내보내기 실패: 마스터 오디오 버스를 만들 수 없어요.");
        return;
      }
      try { master.connect(streamDest); } catch (e) {}

      if (!window.MediaRecorder) {
        alert("내보내기 실패: 이 브라우저는 MediaRecorder를 지원하지 않아요.");
        return;
      }

      // Pick best supported mime type
      const candidates = [
        "audio/wav",
        "audio/webm;codecs=pcm",
        "audio/webm;codecs=opus",
        "audio/webm"
      ];
      let mimeType = "";
      for (const c of candidates) {
        if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(c)) { mimeType = c; break; }
      }

      const rec = new MediaRecorder(streamDest.stream, mimeType ? { mimeType } : undefined);
      const chunks = [];
      rec.ondataavailable = (ev) => { if (ev.data && ev.data.size) chunks.push(ev.data); };

      const fileStamp = new Date().toISOString().replace(/[:.]/g,"-");
      const isWav = (mimeType || "").startsWith("audio/wav");

      rec.onerror = () => {
        alert("내보내기 중 오류가 발생했어요.");
      };

      rec.start();

      // Start playback
      await play();

      // Stop after duration
      await new Promise(res => setTimeout(res, Math.max(500, durationSec * 1000)));

      try { stopOnceInternal(); } catch (e) {}
      try { rec.stop(); } catch (e) {}

      await new Promise(res => { rec.onstop = () => res(); });

      const blob = new Blob(chunks, { type: mimeType || (isWav ? "audio/wav" : "audio/webm") });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = isWav ? `webdaw_${fileStamp}.wav` : `webdaw_${fileStamp}.webm`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 2000);

      if (!isWav) {
        alert("참고: 이 브라우저는 WAV 직접 녹음을 지원하지 않아 WEBM으로 저장했어요. 필요하면 변환해서 사용하면 돼요.");
      }
    }

    window.addEventListener("DOMContentLoaded", () => {
      const btn = document.getElementById("exportWavBtn");
      if (btn) btn.addEventListener("click", exportAudio);
    });
// =========================
    // 프로젝트 데이터
    // =========================
    
// =========================
// Project / Parts Structure (v39)
// =========================
const PART_DEFS = [
  { id: "verseA1",  label: "Verse A (1/2)",  color: "#4a90e2" },
  { id: "verseA2",  label: "Verse A (2/2)",  color: "#6aa8f0" },
  { id: "pre1",     label: "Pre-Chorus (1/2)", color: "#5cb85c" },
  { id: "pre2",     label: "Pre-Chorus (2/2)", color: "#7ad07a" },
  { id: "chorus1",  label: "Chorus (1/2)", color: "#d9534f" },
  { id: "chorus2",  label: "Chorus (2/2)", color: "#e57373" },
];

// === Track scaffold (v58) ===
// We keep the existing single visible/editable piano-roll UI,
// but internally each part owns 4 tracks. For now, the editor
// always targets the activeTrackId ("melody" by default).
const TRACK_DEFS = [
  { id: "melody", label: "Melody", type: "pitched" },
  { id: "keys",   label: "Keys",   type: "pitched" },
  { id: "bass",   label: "Bass",   type: "pitched" },
  { id: "drums",  label: "Drums",  type: "drum"   }
];

let activeTrackId = "melody";

// Bass octave shift (2 octaves down)
const BASS_OCTAVE_SHIFT = -24;
let _bassShiftApplied = false;


const TRACK_COLORS = {
  melody: "#2b7cff",
  keys:   "#8e44ad",
  bass:   "#16a085",
  drums:  "#c0392b"
};

function updateTrackUI() {
  const bar = document.getElementById("trackBar");
  if (!bar) return;
  bar.querySelectorAll(".tbtn").forEach(b => {
    b.classList.toggle("active", b.dataset.track === activeTrackId);
  });
  const dot = document.getElementById("trackDot");
  const lbl = document.getElementById("trackLabel");
  if (dot) dot.style.background = TRACK_COLORS[activeTrackId] || "#999";
  if (lbl) lbl.textContent = activeTrackId;
}

function switchTrack(newId) {
  if (!newId || newId === activeTrackId) return;

  // Save current visible notes into current track
  syncToPart();

  // Switch track
  activeTrackId = newId;

  // Bass: shift existing notes 2 octaves down (once)
  if (activeTrackId === "bass") applyBassOctaveShiftOnce();

  // Load new track notes into editor buffer
  syncFromPart();

  applyTrackMode();
  updateTrackUI();
}


// =========================
// Track mode -> pitches/labels (pitched vs drums)
// =========================
function applyTrackMode() {
  // Preserve cursor + bars, just rebuild pitch rows/labels and visuals
  if (isDrumTrack()) {
    buildPitchList(DRUM_PITCHES_DESC);
  } else if (activeTrackId === "bass") {
    const preset = RANGE_PRESETS[currentRangeKey] || RANGE_PRESETS.male;
    buildPitchData(preset.min + BASS_OCTAVE_SHIFT, preset.max + BASS_OCTAVE_SHIFT);
  } else {
    const preset = RANGE_PRESETS[currentRangeKey] || RANGE_PRESETS.male;
    buildPitchData(preset.min, preset.max);
  }

  buildTimeline();
  buildGrid();
  renderNotes();
  updatePlayheadVisual(cursorCol);
  applyKey();
    renderChordTrack(); // will no-op in drums
}



function bindTrackUI() {
  const bar = document.getElementById("trackBar");
  if (!bar) return;
  bar.querySelectorAll(".tbtn").forEach(b => {
    b.addEventListener("click", () => switchTrack(b.dataset.track));
  });
  
  // Drum bar duplicate (current bar -> next bar)
  const dupBtn = document.getElementById("dupDrumBarBtn");
  if (dupBtn) {
    dupBtn.addEventListener("click", (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      duplicateCurrentDrumBarToNext();
    });
  }
updateTrackUI();
}

function applyBassOctaveShiftOnce() {
  if (_bassShiftApplied) return;
  try {
    // Shift all existing bass notes in all parts so playback + display become consistent
    PART_DEFS.forEach(p => {
      const part = project.parts[p.id];
      if (!part) return;
      ensurePartTracks(part);
      const tr = part.tracks["bass"];
      if (!tr || !Array.isArray(tr.notes)) return;
      tr.notes.forEach(n => { if (typeof n.pitch === "number") n.pitch += BASS_OCTAVE_SHIFT; });
    });
  } catch (e) {}
  _bassShiftApplied = true;
}
function ensurePartTracks(partObj) {
  if (partObj.tracks) return;
  partObj.tracks = {};
  TRACK_DEFS.forEach(t => {
    partObj.tracks[t.id] = { notes: [] };
  });
}

// =========================
// Chord Track Data + UI (v85)
// =========================
const HALF_BARS_PER_PART = 8; // 4 bars * 2
function ensurePartChords(partObj) {
  if (partObj.chords) return;
  partObj.chords = Array.from({ length: HALF_BARS_PER_PART }, () => ({ roman: "" }));
}

// Basic note naming (sharps only for now)
const NOTE_NAMES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];

function romanToDegree(roman) {
  // strip dim sign and non-letters
  const r = String(roman || "").replace(/[^ivIV]/g, "");
  const map = { "I":1,"II":2,"III":3,"IV":4,"V":5,"VI":6,"VII":7 };
  const up = r.toUpperCase();
  return map[up] || 1;
}
function romanQualitySuffix(roman) {
  const s = String(roman || "");
  if (s.includes("°")) return "dim";
  // lowercase = minor (ii, iii, vi)
  const letters = s.replace(/[^ivIV]/g,"");
  if (letters && letters === letters.toLowerCase()) return "m";
  return ""; // major
}
function chordNameFromRoman(roman) {
  const scalePcs = getScalePcsArray(); // 7 pitch classes in current key/scale
  const deg = romanToDegree(roman);
  const rootPc = scalePcs[(deg - 1) % 7];
  const rootName = NOTE_NAMES[rootPc % 12];
  const q = romanQualitySuffix(roman);
  if (q === "dim") return rootName + "dim";
  if (q === "m") return rootName + "m";
  return rootName;
}

function applyChordPresetToChordTrack() {
  const part = project.parts[project.currentPartId];
  if (!part) return;
  ensurePartChords(part);
  if (!activeChordPresetId) {
    // keep existing chords; just re-render
    renderChordTrack();
    return;
  }
  const preset = CHORD_PRESETS[activeChordPresetId];
  if (!preset) { renderChordTrack(); return; }
  // preset is 4 bars -> expand to 8 half-bars by duplicating each bar
  for (let i = 0; i < HALF_BARS_PER_PART; i++) {
    const barIdx = Math.floor(i / 2); // 0..3
    const roman = preset[barIdx % preset.length] || "";
    part.chords[i].roman = roman;
  }
  renderChordTrack();
  applyPresetToGridCells();
}


function getRomanOptionsForUi() {
  // For now: classic diatonic triads by scale type.
  if (currentScaleType === "minor") {
    return ["i","ii°","III","iv","v","VI","VII"];
  }
  return ["I","ii","iii","IV","V","vi","vii°"];
}

function renderChordTrack() {
  const wrap = document.getElementById("chordTrack");
  if (!wrap) return;
  const part = project.parts[project.currentPartId];
  if (!part) { wrap.innerHTML = ""; return; }
  ensurePartChords(part);

  const romanList = getRomanOptionsForUi();

  wrap.innerHTML = "";
  for (let i = 0; i < HALF_BARS_PER_PART; i++) {
    const slot = part.chords[i] || { roman: "" };
    const roman = slot.roman || "";

    const el = document.createElement("div");
    el.className = "chordslot" + (roman ? "" : " empty");
    el.dataset.idx = String(i);

    const sel = document.createElement("select");
    sel.className = "chordselect";

    const optBlank = document.createElement("option");
    optBlank.value = "";
    optBlank.textContent = "—";
    sel.appendChild(optBlank);

    romanList.forEach(rn => {
      const opt = document.createElement("option");
      opt.value = rn;
      opt.textContent = rn + " (" + chordNameFromRoman(rn) + ")";
      sel.appendChild(opt);
    });

    sel.value = roman;

    sel.addEventListener("change", () => {
      const v = sel.value || "";
      part.chords[i].roman = v;

      // Manual edits should break "preset active" highlight (preset = one-shot action)
      if (activeChordPresetId) {
        activeChordPresetId = "";
        const presetSel = document.getElementById("chordPresetSel");
        if (presetSel) presetSel.value = "";
        applyPresetToGridCells();
      }
      renderChordTrack();
      applyPresetToGridCells();
    });

    el.appendChild(sel);
    wrap.appendChild(el);
  }
}


function getActiveTrackNotes() {
  const part = project.parts[project.currentPartId];
  if (!part) return [];
  ensurePartTracks(part);
  return part.tracks[activeTrackId].notes;
}

const project = {
  bpm: 90,
  timeSignature: [4, 4],
  bars: 4,               // each part is always 4 bars
  currentPartId: "verseA1",
  parts: {},
  tracks: [{ name: "Piano", notes: [] }]
};

PART_DEFS.forEach(p => {
  project.parts[p.id] = {}; ensurePartTracks(project.parts[p.id]); ensurePartChords(project.parts[p.id]);
});

function syncFromPart() {
  project.tracks[0].notes = getActiveTrackNotes();
}
function syncToPart() {
  const part = project.parts[project.currentPartId];
  ensurePartTracks(part);
  part.tracks[activeTrackId].notes = project.tracks[0].notes;
}


function getPartNotes(partId) {
  const part = project.parts[partId];
  if (!part) return [];
  ensurePartTracks(part);
  return part.tracks["melody"].notes; // v58: legacy behavior = melody only
}
// start on Verse A (1/2)
syncFromPart();
// =========================
// View mode: part vs full (v42)
// =========================
let viewMode = "part";
let lastInsertStep = 1; // "part" | "full"

function recomputeCols() {
  totalCols = project.bars * beatsPerBar * SUBDIV;
}

function rebuildUIAfterBarsChange() {
  recomputeCols();
  buildTimeline();
  buildGrid();
  renderNotes();
  updatePlayheadVisual(cursorCol);
}

function buildCombinedNotesForFull() {
  // persist current part edits first
  syncToPart();

  const combined = [];
  let gid = 100000;
  PART_DEFS.forEach((p, i) => {
    const offset = i * 4; // 4 bars per part
    const notes = getPartNotes(p.id) || [];
    notes.forEach(n => {
      combined.push({
        id: gid++,
        bar: n.bar + offset,
        beat: n.beat,
        length: n.length,
        pitch: n.pitch
      });
    });
  });
  return combined;
}

function setViewMode(mode) {
  if (mode === viewMode) return;

  if (mode === "full") {
    viewMode = "full";
    project.bars = 24; // 6 parts * 4 bars
    // show combined notes in the visible track (read-only mode)
    project.tracks[0].notes = buildCombinedNotesForFull();
  } else {
    // back to part editing
    viewMode = "part";
    project.bars = 4;
    syncFromPart();
  }

  // disable editing interactions in full view
  gridEl.classList.toggle("readonly", viewMode === "full");

  rebuildUIAfterBarsChange();
  updatePartHeader();
}

window.setViewMode = setViewMode;



// =========================
// Part Switching (v40)
// =========================
function updatePartHeader() {
  const h = document.getElementById("partHeader");
  if (!h) return;
  if (typeof viewMode !== "undefined" && viewMode === "full") {
    h.textContent = "Full View · 24 Bars (Read-only)";
    h.style.background = "#111";
    return;
  }
  const p = PART_DEFS.find(x => x.id === project.currentPartId);
  if (!p) return;
  h.textContent = p.label + " · 4 Bars";
  h.style.background = p.color;
}

// paint initial part header
updatePartHeader();

function switchPart(partId) {
  if (!project.parts[partId]) return;

  // save current visible notes into the current part
  syncToPart();

  // switch
  project.currentPartId = partId;

  // load selected part notes into visible track
  syncFromPart();

  applyTrackMode();
  updateTrackUI();
  updatePartHeader();  applyPresetToGridCells();
  applyChordPresetToChordTrack();
  renderChordTrack();
}

// expose for inline onclick
window.switchPart = switchPart;


    // =========================
    // 피아노롤 설정
    // =========================
    const PITCH_MIN = 48; // C3
    const PITCH_MAX = 71; // B4

    const beatsPerBar = project.timeSignature[0]; // 4
    let totalCols = project.bars * beatsPerBar * SUBDIV; // 4 bars * 4 beats * 4 = 64

    let pitches = [];
    for (let p = PITCH_MAX; p >= PITCH_MIN; p--) pitches.push(p);

    let pitchToRow = new Map();
    pitches.forEach((p, i) => pitchToRow.set(p, i));

    let nextNoteId = 1;
    // =========================
    // Key / Scale (표시 + 코드 연주)
    // =========================
    let currentKeyRoot = 0; // 0=C
    let currentScaleType = "major";

    // 코드 찍기/입력 길이(16분음표 단위): 4=1/4, 2=1/8, 1=1/16
    let insertLen = 1;

    const SCALE_MAJOR = [0, 2, 4, 5, 7, 9, 11];
    const SCALE_MINOR = [0, 2, 3, 5, 7, 8, 10]; // natural minor

    function getScaleSemis() {
      return (currentScaleType === "minor") ? SCALE_MINOR : SCALE_MAJOR;
    }

    function getScalePitchClassSet() {
      const base = getScaleSemis();
      return new Set(base.map(x => (x + currentKeyRoot) % 12));
    }

    // =========================
// Chord presets (v51)
// =========================
const CHORD_PRESETS = {
  p1: ["I","iii","IV","V"],   // C Em F G
  p2: ["I","vi","IV","V"],    // C Am F G
  p3: ["I","V","vi","IV"],    // C G Am F
};

// Roman triads -> scale degrees (major/minor)
const ROMAN_DEGREES_MAJOR = { "I":[1,3,5], "ii":[2,4,6], "iii":[3,5,7], "IV":[4,6,1], "V":[5,7,2], "vi":[6,1,3], "vii°":[7,2,4] };
const ROMAN_DEGREES_MINOR = { "i":[1,3,5], "ii°":[2,4,6], "III":[3,5,7], "iv":[4,6,1], "v":[5,7,2], "VI":[6,1,3], "VII":[7,2,4] };

let activeChordPresetId = "";   // "", "p1" | "p2" | "p3"
let autoChordEnabled = false;

function getScalePcsArray() {
  const base = getScaleSemis(); // semitones from tonic for current scale
  return base.map(x => (x + currentKeyRoot) % 12); // 7 pitch classes
}

function getChordTonePcSetForRoman(roman) {
  const rn = String(roman || "");
  if (!rn) return null;

  const scalePcs = getScalePcsArray();
  const degMap = (currentScaleType === "minor") ? ROMAN_DEGREES_MINOR : ROMAN_DEGREES_MAJOR;

  // exact match first, then try without dim sign
  const degrees = degMap[rn] || degMap[rn.replace("°","")] || null;
  if (!degrees) return null;

  const pcs = new Set();
  degrees.forEach(deg => {
    const idx = (deg - 1) % 7;
    pcs.add(scalePcs[idx]);
  });
  return pcs;
}

function getChordTonePcSetForHalfIndex(halfIdx0) {
  const part = project.parts[project.currentPartId];
  if (!part) return null;
  ensurePartChords(part);
  const slot = part.chords[halfIdx0];
  if (!slot || !slot.roman) return null;
  return getChordTonePcSetForRoman(slot.roman);
}

function applyPresetToGridCells() {
  // Stage 4 grid shading: always show Scale (and Chord tones if chord track has values)
  if (isDrumTrack()) { document.body.classList.remove('presetActive'); return; }
  document.body.classList.add("presetActive");

  const part = project.parts[project.currentPartId];
  if (part) ensurePartChords(part);

  const cells = gridEl.querySelectorAll(".cell");
  cells.forEach(cell => {
    const bar = Number(cell.dataset.bar);
    const beat16 = Number(cell.dataset.beat);
    const pitch = Number(cell.dataset.pitch);
    const pc = ((pitch % 12) + 12) % 12;

    const inScale = isInCurrentKey(pitch);
    cell.classList.toggle("scale", inScale);

    // Determine active half-bar slot for this cell
    const col = (bar - 1) * (beatsPerBar * SUBDIV) + (beat16 - 1);
    const halfIdx = Math.floor(col / 8); // 8 cols per half-bar
    const chordPcs = getChordTonePcSetForHalfIndex(halfIdx);
    const inChord = chordPcs ? chordPcs.has(pc) : false;
    cell.classList.toggle("chord", inChord);
  });
}


function isInCurrentKey(midi) {
      if (typeof isDrumTrack === 'function' && isDrumTrack()) return true;
      return getScalePitchClassSet().has(((midi % 12) + 12) % 12);
    }

    function updateKeyHighlights() {
      if (isDrumTrack()) return;
      // 라벨: pitches 순서와 labelsEl 자식 순서가 같음
      const labelEls = labelsEl.querySelectorAll(".label");
      for (let i = 0; i < labelEls.length; i++) {
        const pitch = pitches[i];
        labelEls[i].classList.toggle("outKey", !isInCurrentKey(pitch));
      }

      // 셀
      const cells = gridEl.querySelectorAll(".cell");
      cells.forEach(c => {
        const pitch = Number(c.dataset.pitch);
        c.classList.toggle("outKey", !isInCurrentKey(pitch));
      });
    }

    function applyKey() {
      const rootEl = document.getElementById("keyRoot");
      const scaleEl = document.getElementById("scaleType");
      if (rootEl) currentKeyRoot = Number(rootEl.value);
      if (scaleEl) currentScaleType = scaleEl.value;
      updateKeyHighlights();
      applyPresetToGridCells();
      renderChordTrack();
    }



    

    function initInsertLenButtons() {
      const seg = document.getElementById("insertLenSeg");
      if (!seg) return;
      const btns = Array.from(seg.querySelectorAll("button[data-len]"));
      const setActive = (len) => {
        insertLen = len;
        lastInsertStep = len;
        btns.forEach(b => b.classList.toggle("active", Number(b.dataset.len) === len));
      };
      btns.forEach(b => b.addEventListener("click", () => setActive(Number(b.dataset.len))));
      const active = btns.find(b => b.classList.contains("active"));
      setActive(active ? Number(active.dataset.len) : 1);
    }
// =========================
    // 시간 변환 (마디/16분 -> 초)
    // =========================
    function positionToSeconds(bar, beat16, bpm) {
      const sixteenth = (60 / bpm) / SUBDIV;
      return (bar - 1) * beatsPerBar * SUBDIV * sixteenth
           + (beat16 - 1) * sixteenth;
    }
    function lengthToSeconds(length16, bpm) {
      return length16 * (60 / bpm) / SUBDIV;
    }

    // =========================
    // 위치 변환
    // =========================
    function posToCol(bar, beat16) {
      return (bar - 1) * beatsPerBar * SUBDIV + (beat16 - 1);
    }
    function findNoteIndexAtStart(trackNotes, bar, beat16, pitch) {
      return trackNotes.findIndex(n => n.bar === bar && n.beat === beat16 && n.pitch === pitch);
    }

    // 클릭한 col(0-base)이 기존 노트의 범위(start~end)에 포함되는지 찾기
    function findNoteIndexCovering(trackNotes, col, pitch) {
      return trackNotes.findIndex(n => {
        if (n.pitch !== pitch) return false;
        const startCol = posToCol(n.bar, n.beat);
        const endCol = startCol + Math.max(1, n.length) - 1;
        return col >= startCol && col <= endCol;
    });
  }

function rangesOverlap(aStart, aLen, bStart, bLen) {
  const aEnd = aStart + Math.max(1, aLen) - 1;
  const bEnd = bStart + Math.max(1, bLen) - 1;
  return !(aEnd < bStart || bEnd < aStart);
}

// ✅ noteIndex의 노트가 다른 노트(같은 pitch)와 겹치면 겹치는 노트들을 삭제 (overwrite 방식)
function removeOverlapsSamePitch(notes, noteIndex) {
  const n = notes[noteIndex];
  if (!n) return noteIndex;

  const aStart = posToCol(n.bar, n.beat);
  const aLen = Math.max(1, n.length);

  // 뒤에서부터 지워야 index 꼬임이 적음
  for (let i = notes.length - 1; i >= 0; i--) {
    if (i === noteIndex) continue;
    const m = notes[i];
    if (!m) continue;
    if (m.pitch !== n.pitch) continue;

    const bStart = posToCol(m.bar, m.beat);
    const bLen = Math.max(1, m.length);

    if (rangesOverlap(aStart, aLen, bStart, bLen)) {
      notes.splice(i, 1);
      if (i < noteIndex) noteIndex--; // 앞쪽 노트가 지워지면 noteIndex 보정
    }
  }
  return noteIndex;
}






    // =========================
    // UI 엘리먼트
    // =========================
    const labelsEl = document.getElementById("labels");
    const gridWrapEl = document.getElementById("gridWrap");

// =========================
// 플레이헤드(포지션 바) / 커서
// =========================
const playheadEl = document.getElementById("playhead");
let cursorCol = 0;
    let stopArmed = false; // press Stop twice to reset to start // 0..totalCols-1 (16분음표 칸)

// =========================
// Drum helper: duplicate current bar to next bar (drums only)
// =========================
function duplicateCurrentDrumBarToNext() {
  // Ensure current editor notes are saved before we edit part data
  try { syncToPart(); } catch (e) {}

  const srcBar = Math.floor(cursorCol / 16) + 1; // 1..bars
  const dstBar = srcBar + 1;

    // ✅ 다음 마디로 커서(플레이헤드) 이동해서 연타 시 2→3→4로 계속 진행되게
  cursorCol = (dstBar - 1) * 16;   // 16 = 1마디(16분음표 16칸)
  updatePlayheadVisual(cursorCol);

  if (dstBar > project.bars) {
    alert("마지막 마디입니다. 다음 마디로 복사할 수 없어요.");
    return;
  }

  const part = project.parts[project.currentPartId];
  if (!part) return;
  ensurePartTracks(part);

  const drumsTrack = part.tracks["drums"];
  if (!drumsTrack) return;

  const srcNotes = (drumsTrack.notes || []).filter(n => n.bar === srcBar);
  // Replace destination bar contents (clean paste)
  drumsTrack.notes = (drumsTrack.notes || []).filter(n => n.bar !== dstBar);

  for (const n of srcNotes) {
    drumsTrack.notes.push({
      id: nextNoteId++,
      bar: dstBar,
      beat: n.beat,
      length: n.length,
      pitch: n.pitch
    });
  }

  // If currently viewing drums, refresh editor buffer
  if (activeTrackId === "drums") {
    syncFromPart();
  }

  // Redraw
  try { renderNotes(); } catch (e) {}
  try { applyPresetToGridCells(); } catch (e) {}
}
let rafId = null;

function colToTransportPos(col) {
  const measures = Math.floor(col / 16);
  const beat16 = col % 16;
  const quarters = Math.floor(beat16 / 4);
  const six = beat16 % 4;
  return `${measures}:${quarters}:${six}`;
      if (activeChordPresetId) applyPresetToGridCells();
    }


function noteToTransportPos(note) {
  const measures = note.bar - 1;
  const quarters = Math.floor((note.beat - 1) / 4);
  const six = (note.beat - 1) % 4;
  return `${measures}:${quarters}:${six}`;
}

function updatePlayheadVisual(col) {
  if (!playheadEl) return;
  playheadEl.style.left = `${col * CELL}px`;
  playheadEl.classList.remove("hidden");
}

function advanceCursorAfterInsert() {
  const step = lastInsertStep || 1; // step is in 16th-cells (1=1/16, 2=1/8, 4=1/4)
  cursorCol = Math.min(cursorCol + step, totalCols - 1);
  updatePlayheadVisual(cursorCol);

  // keep cursor visible
  const wrap = document.querySelector(".gridwrap");
  if (wrap) {
    const x = cursorCol * CELL; // CELL is px per column
    if (x < wrap.scrollLeft + 20) wrap.scrollLeft = Math.max(0, x - 20);
    if (x > wrap.scrollLeft + wrap.clientWidth - 40) wrap.scrollLeft = x - (wrap.clientWidth - 40);
  }
}


function setCursorCol(col) {
      stopArmed = false;
  cursorCol = Math.max(0, Math.min(totalCols - 1, col));
  if (Tone.Transport.state !== "started") updatePlayheadVisual(cursorCol);
}

function startPlayheadLoop() {
  if (rafId) cancelAnimationFrame(rafId);
  playheadEl.classList.remove("hidden");

  const tick = () => {
      if (Tone.Transport.state === "started") {
        // Transport.position = "measures:quarters:sixteenths" (0-based measures)
        const pos = Tone.Transport.position.toString();
        const parts = pos.split(":").map(x => Number(x));
        const m = (Number.isFinite(parts[0]) ? parts[0] : 0);
        const q = (Number.isFinite(parts[1]) ? parts[1] : 0);
        const s = (Number.isFinite(parts[2]) ? parts[2] : 0);
        const col = Math.max(0, Math.min(totalCols - 1, m * 16 + q * 4 + s));
        updatePlayheadVisual(col);
      }
      rafId = requestAnimationFrame(tick);
    };
  rafId = requestAnimationFrame(tick);
}

function stopPlayheadLoop() {
  if (rafId) cancelAnimationFrame(rafId);
  rafId = null;
  updatePlayheadVisual(cursorCol);
}

// 타임라인 클릭으로 커서 위치 지정
document.getElementById("timeline").addEventListener("click", (e) => {
  const t = e.target;
  if (!t || !t.classList || !t.classList.contains("tick")) return;
  const col = Number(t.dataset.col);
  if (!Number.isFinite(col)) return;
  setCursorCol(col);
});

    const gridEl = document.getElementById("grid");

// Prevent iOS/Safari long-press text selection & context menu on the grid
gridEl.addEventListener("contextmenu", (e) => e.preventDefault());
gridEl.addEventListener("selectstart", (e) => e.preventDefault());
    const notesLayerEl = document.getElementById("notesLayer");
    const timelineEl = document.getElementById("timeline");
    const bpmEl = document.getElementById("bpm");

    function midiToName(m) {
      const names = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
      const name = names[m % 12];
      const oct = Math.floor(m / 12) - 1;
      return `${name}${oct}`;
    }


// =========================
// Drums (GM) - 9 rows
// =========================
// GM drum notes (channel 10). We keep only 9 core pieces for now.
const DRUM_ROWS = [
  { name: "Ride",        midi: 51 }, // Ride Cymbal 1
  { name: "Crash",       midi: 49 }, // Crash Cymbal 1
  { name: "Tom 1",       midi: 50 }, // High Tom
  { name: "Tom 2",       midi: 47 }, // Low-Mid Tom
  { name: "Tom 3",       midi: 43 }, // High Floor Tom
  { name: "Open HH",     midi: 46 }, // Open Hi-Hat
  { name: "Closed HH",   midi: 42 }, // Closed Hi-Hat
  { name: "Snare",       midi: 38 }, // Acoustic Snare
  { name: "Kick",        midi: 36 }, // Bass Drum 1
];
const DRUM_NAME_BY_MIDI = new Map(DRUM_ROWS.map(d => [d.midi, d.name]));
const DRUM_PITCHES_DESC = DRUM_ROWS.map(d => d.midi).sort((a,b)=>b-a);

function isDrumTrack() {
  return activeTrackId === "drums";
}

function buildPitchList(listDesc){
  pitches = [...listDesc]; // already desc (high -> low)
  pitchToRow = new Map();
  pitches.forEach((p,i)=>pitchToRow.set(p,i));
}


// ===== Range presets (MIDI) =====
let currentRangeKey = 'male'; // remember last pitched range

const RANGE_PRESETS = {

  full:  { min: 48, max: 71 }, // C3..B4 (2 oct)
  male:  { min: 52, max: 69 }, // E3..A4 (~1.5 oct)
  female:{ min: 55, max: 72 }  // G3..C5 (~1.5 oct)
};

function buildPitchData(minMidi, maxMidi){
  pitches = [];
  for (let p=maxMidi; p>=minMidi; p--) pitches.push(p);
  pitchToRow = new Map();
  pitches.forEach((p,i)=>pitchToRow.set(p,i));
}

function setRangePreset(key){
  if (typeof isDrumTrack==='function' && isDrumTrack()) return; // ignore while drums
  currentRangeKey = key;
  const preset = RANGE_PRESETS[key] || RANGE_PRESETS.full;
  buildPitchData(preset.min, preset.max);
  buildGrid();
  renderNotes();
  updatePlayheadVisual(cursorCol);
}



function lockGridScroll() {
  const wrap = document.querySelector(".gridwrap");
  if (!wrap) return;
  wrap.dataset.prevOverflowX = wrap.style.overflowX || "";
  wrap.dataset.prevTouchAction = wrap.style.touchAction || "";
  wrap.style.overflowX = "hidden";
  wrap.style.touchAction = "none";
}
function unlockGridScroll() {
  const wrap = document.querySelector(".gridwrap");
  if (!wrap) return;
  wrap.style.overflowX = wrap.dataset.prevOverflowX || "auto";
  wrap.style.touchAction = wrap.dataset.prevTouchAction || "pan-x";
}
    function buildTimeline() {
      document.getElementById("timeline").style.gridTemplateColumns = `repeat(${totalCols}, ${CELL}px)`;
      document.getElementById("timeline").innerHTML = "";

      for (let col = 0; col < totalCols; col++) {
        const bar = Math.floor(col / (beatsPerBar * SUBDIV)) + 1;
        const beat16 = (col % (beatsPerBar * SUBDIV)) + 1;

        const tick = document.createElement("div");
        tick.className = "tick";
        tick.dataset.col = col;

        // 1) 마디 첫 칸에는 마디 번호
        // 2) 그 외에는 박(1~4)만 표시 (16분은 너무 복잡하니까)
        if (beat16 === 1) {
          tick.classList.add("bar");
          tick.textContent = `${bar}`;
        } else if ((beat16 - 1) % SUBDIV === 0) {
          tick.textContent = `${((beat16 - 1) / SUBDIV) + 1}`; // 2,3,4 박
        } else {
          tick.textContent = "";
        }

        document.getElementById("timeline").appendChild(tick);
      }
    }

    function buildGrid() {
      // 라벨
      labelsEl.style.gridTemplateRows = `repeat(${pitches.length}, ${CELL}px)`;
      labelsEl.innerHTML = "";
      pitches.forEach(p => {
        const div = document.createElement("div");
        div.className = "label";
        if (!isDrumTrack()) {
          if (!isInCurrentKey(p)) div.classList.add("outKey");
          div.textContent = midiToName(p);
        } else {
          div.textContent = DRUM_NAME_BY_MIDI.get(p) || midiToName(p);
        }
        labelsEl.appendChild(div);
      });

      // 그리드
      gridEl.style.gridTemplateColumns = `repeat(${totalCols}, ${CELL}px)`;
      gridEl.style.gridTemplateRows = `repeat(${pitches.length}, ${CELL}px)`;
      gridEl.innerHTML = "";

      // 래퍼 크기
      const width = totalCols * CELL + 2;
      const height = pitches.length * CELL + 2;
      gridWrapEl.style.width = `${width}px`;
      gridWrapEl.style.height = `${height}px`;

      for (let row = 0; row < pitches.length; row++) {
        for (let col = 0; col < totalCols; col++) {
          const cell = document.createElement("div");
          cell.className = "cell";

          const bar = Math.floor(col / (beatsPerBar * SUBDIV)) + 1;
          const beat16 = (col % (beatsPerBar * SUBDIV)) + 1;
          const pitch = pitches[row];

          if (!isDrumTrack()) {
            if (!isInCurrentKey(pitch)) cell.classList.add("outKey");
          }

          cell.dataset.bar = String(bar);
          cell.dataset.beat = String(beat16);
          cell.dataset.pitch = String(pitch);

          // 마디/박 경계 표시
          if (beat16 === 1) cell.classList.add("barline");
          if ((beat16 - 1) % SUBDIV === 0) cell.classList.add("beatline");

          gridEl.appendChild(cell);
        }
      }
    }

    // =========================
    // 노트 렌더(블록)
    // =========================
    function renderNotes(editingId = null) {
      notesLayerEl.innerHTML = "";

      const notes = project.tracks[0].notes;
      for (const n of notes) {
        const row = pitchToRow.get(n.pitch);
        if (row === undefined) continue;

        const startCol = posToCol(n.bar, n.beat);
        const length = Math.max(1, n.length);
        const endCol = Math.min(totalCols - 1, startCol + length - 1);

        const left = startCol * CELL + 1;
        const top = row * CELL + 1;
        const width = (endCol - startCol + 1) * CELL - 2;

        const div = document.createElement("div");
        div.className = "note";
        if (editingId && n.id === editingId) {
          div.classList.add("editing");
          if (dragState && dragState.mode === "move") div.classList.add("moving");
        }

        div.style.left = `${left}px`;
        div.style.top = `${top}px`;
        div.style.width = `${Math.max(6, width)}px`;

        notesLayerEl.appendChild(div);
      }
    }

    // =========================
    // Undo
    // =========================
    const history = [];
    const HISTORY_LIMIT = 50;

    function snapshot() {
      return JSON.parse(JSON.stringify(project.tracks[0].notes));
    }
    function pushHistory() {
      history.push(snapshot());
      if (history.length > HISTORY_LIMIT) history.shift();
    }
    function undo() {
      if (history.length === 0) return;
      project.tracks[0].notes = history.pop();
      renderNotes();
    }
    document.addEventListener("keydown", (e) => {
      const z = e.key.toLowerCase() === "z";
      if (z && (e.metaKey || e.ctrlKey)) {
        e.preventDefault();
        undo();
      }
    });

    // =========================
    // 입력: 클릭 삭제 + 드래그 길이
    // =========================
    let dragState = null;



// =========================
// Gesture edit (tap delete / long-press move / immediate drag resize)
// =========================
const TAP_MAX_MS = 250;
const LONGPRESS_MS = 600;
const MOVE_THRESHOLD = 10; // px

let pressTimer = null;
let pressStartTime = 0;
let pressStartX = 0;
let pressStartY = 0;
let pendingNoteIndex = null;
let pendingDidHistory = false;

function clearPressTimer() {
  if (pressTimer) {
    clearTimeout(pressTimer);
    pressTimer = null;
  }
}
    
gridEl.addEventListener("pointerdown", (e) => {
      if (typeof viewMode !== 'undefined' && viewMode === 'full') return;
  const cell = document.elementFromPoint(e.clientX, e.clientY);
  if (!cell || !cell.classList.contains("cell")) return;

  e.preventDefault();
  gridEl.setPointerCapture(e.pointerId);
  lockGridScroll();

  pressStartTime = Date.now();
  pressStartX = e.clientX;
  pressStartY = e.clientY;
  pendingNoteIndex = null;
  pendingDidHistory = false;
  clearPressTimer();

  const bar = Number(cell.dataset.bar);
  const beat16 = Number(cell.dataset.beat);
  const pitch = Number(cell.dataset.pitch);
  const col = posToCol(bar, beat16);

  const notes = project.tracks[0].notes;

  // 1) start-cell index (for legacy behavior)
  const idxStart = findNoteIndexAtStart(notes, bar, beat16, pitch);
  // 2) any-cover index (note body)
  const idxCover = findNoteIndexCovering(notes, col, pitch);

  // --- Existing note: gesture edit ---
  if (idxCover >= 0) {
    pendingNoteIndex = idxCover;

    // Long-press => move mode
    pressTimer = setTimeout(() => {
      if (pendingNoteIndex === null) return;
      const n = notes[pendingNoteIndex];
      if (!n) return;
      if (!pendingDidHistory) { pushHistory(); pendingDidHistory = true; }

      dragState = {
        mode: "move",
        noteIndex: pendingNoteIndex,
        moved: false,
      };
      renderNotes(n.id);
    }, LONGPRESS_MS);

    // Pending state: on quick tap => delete, on early move => resize
    dragState = {
      mode: "pending",
      noteIndex: pendingNoteIndex,
      startCol: posToCol(notes[pendingNoteIndex].bar, notes[pendingNoteIndex].beat),
      startLen: notes[pendingNoteIndex].length
    };
    renderNotes(notes[pendingNoteIndex].id);
    return;
  }

  // --- Empty cell: create (existing behavior) ---
  pushHistory();
  const n = { id: nextNoteId++, bar, beat: beat16, length: 1, pitch };
  notes.push(n);
  
  // 🔊 audition on create
  auditionPitch(pitch);
dragState = { mode: "create", startCol: col, noteIndex: notes.length - 1, moved: false };
  renderNotes(n.id);
});

gridEl.addEventListener("pointermove", (e) => {
  if (!dragState) return;

  // If we are pending on an existing note, decide between resize (early drag) or keep waiting for long-press (move)
  if (dragState.mode === "pending") {
    const dx = Math.abs(e.clientX - pressStartX);
    const dy = Math.abs(e.clientY - pressStartY);
    if (dx > MOVE_THRESHOLD || dy > MOVE_THRESHOLD) {
      clearPressTimer();
      const notes = project.tracks[0].notes;
      const n = notes[dragState.noteIndex];
      if (!n) return;
      if (!pendingDidHistory) { pushHistory(); pendingDidHistory = true; }

      dragState.mode = "resize_existing";
      // fallthrough to apply resize below
    } else {
      return; // still waiting
    }
  }

  // Create-drag (existing)
  if (dragState.mode === "create") {
    const cell = document.elementFromPoint(e.clientX, e.clientY);
    if (!cell || !cell.classList.contains("cell")) return;
    const bar = Number(cell.dataset.bar);
    const beat16 = Number(cell.dataset.beat);
    const col = posToCol(bar, beat16);

    const notes = project.tracks[0].notes;
    const n = notes[dragState.noteIndex];
    if (!n) return;
    const newLen = Math.max(1, (col - dragState.startCol) + 1);
    if (newLen !== n.length) dragState.moved = true;
    n.length = newLen;
    // ✅ 드래그로 늘리다가 기존 노트와 겹치면 기존 노트 제거
    dragState.noteIndex = removeOverlapsSamePitch(notes, dragState.noteIndex);
    renderNotes(n.id);
    return;
  }

  // Move (after long-press)
  if (dragState.mode === "move") {
    const cell = document.elementFromPoint(e.clientX, e.clientY);
    if (!cell || !cell.classList.contains("cell")) return;
    const bar = Number(cell.dataset.bar);
    const beat16 = Number(cell.dataset.beat);
    const pitch = Number(cell.dataset.pitch);

    const notes = project.tracks[0].notes;
    const n = notes[dragState.noteIndex];
    if (!n) return;


    // mark moved only if something actually changes
    if (n.bar !== bar || n.beat !== beat16 || n.pitch !== pitch) dragState.moved = true;
    n.bar = bar;
    n.beat = beat16;
    n.pitch = pitch;
    dragState.noteIndex = removeOverlapsSamePitch(notes, dragState.noteIndex);
    renderNotes(n.id);
    return;
  }

  // Resize existing (early drag on a note)
  if (dragState.mode === "resize_existing") {
    const cell = document.elementFromPoint(e.clientX, e.clientY);
    if (!cell || !cell.classList.contains("cell")) return;
    const bar = Number(cell.dataset.bar);
    const beat16 = Number(cell.dataset.beat);
    const col = posToCol(bar, beat16);

    const notes = project.tracks[0].notes;
    const n = notes[dragState.noteIndex];
    if (!n) return;

    const newLen = Math.max(1, (col - dragState.startCol) + 1);
    n.length = newLen;
    dragState.noteIndex = removeOverlapsSamePitch(notes, dragState.noteIndex);
    renderNotes(n.id);
    return;
  }

  // Legacy resize mode (if any older logic triggers it)
  if (dragState.mode === "resize") {
    const cell = document.elementFromPoint(e.clientX, e.clientY);
    if (!cell || !cell.classList.contains("cell")) return;
    const bar = Number(cell.dataset.bar);
    const beat16 = Number(cell.dataset.beat);
    const col = posToCol(bar, beat16);

    const notes = project.tracks[0].notes;
    const n = notes[dragState.noteIndex];
    if (!n) return;
    const FinalLen = Math.max(1, (col - dragState.startCol) + 1);
    n.length = FinalLen;
    renderNotes(n.id);
  }
});

gridEl.addEventListener("pointerup", () => {
  unlockGridScroll();
  clearPressTimer();

  const elapsed = Date.now() - pressStartTime;

  // Quick tap on existing note => delete
  if (dragState && dragState.mode === "pending" && pendingNoteIndex !== null && elapsed <= TAP_MAX_MS) {
    const notes = project.tracks[0].notes;
    if (!pendingDidHistory) { pushHistory(); pendingDidHistory = true; }
    notes.splice(pendingNoteIndex, 1);
    dragState = null;
    pendingNoteIndex = null;
    renderNotes();
    return;
  }

  // If we just finished moving a note, audition the final pitch once
  if (dragState && dragState.mode === "move") {
    const notes = project.tracks[0].notes;
    const idx = dragState.noteIndex;
    if (typeof idx === "number" && notes[idx] && dragState.moved) {
      auditionPitch(notes[idx].pitch);
    }
  }

  // End create / move / resize
  dragState = null;
  pendingNoteIndex = null;
  renderNotes();
});

gridEl.addEventListener("pointercancel", () => {
  unlockGridScroll();
  clearPressTimer();
  dragState = null;
  pendingNoteIndex = null;
  renderNotes();
});

// On iOS Safari, prevent scroll while drawing/resizing notes
gridEl.addEventListener("touchmove", (e) => {
  if (dragState) e.preventDefault();
}, { passive: false });
    function applyBpm() {
      const v = Number(bpmEl.value);
      if (!Number.isFinite(v) || v < 30 || v > 240) return;
      project.bpm = v;
      Tone.Transport.bpm.value = project.bpm;
    }
    function clearNotes() {
      pushHistory();
      project.tracks[0].notes = [];
      renderNotes();
    }

    // =========================
    // 재생/정지 + 악기(soundfont-player)
    // - 기존처럼 Soundfont.instrument(...) 방식으로 트랙별 악기를 분리
    // =========================
    let pianoInst = null;     // Keys
    let oboeInst  = null;     // Melody
    let bassInst  = null;     // Bass (finger)
    let drumInst  = null;     // Drums (GM kit)

    let auditionSeq = 0;

    let pianoReadyPromise = null;
    let oboeReadyPromise  = null;
    let bassReadyPromise  = null;
    
let drumReadyPromise  = null;
// Drum soundfont: use a real GM Standard Drum Kit (channel 10 / program 1 concept).
// In soundfont-player we pick the kit instrument by name; channel routing isn't needed.
let standardKitScriptPromise = null;
function ensureStandardKitScript() {
  if (standardKitScriptPromise) return standardKitScriptPromise;
  standardKitScriptPromise = new Promise((resolve, reject) => {
    const existing = document.querySelector('script[data-sf="gm-standard-kit"]');
    if (existing) return resolve(true);
    const s = document.createElement('script');
    s.dataset.sf = "gm-standard-kit";
    // FluidR3_GM provides "standard_kit" in MIDI.js soundfont format.
    s.src = "https://gleitz.github.io/midi-js-soundfonts/FluidR3_GM/standard_kit-mp3.js";
    s.async = true;
    s.onload = () => resolve(true);
    s.onerror = () => reject(new Error("Failed to load GM standard_kit soundfont script"));
    document.head.appendChild(s);
  });
  return standardKitScriptPromise;
}


// =========================
// Audio unlock / prime (iOS safe)
// - Must be triggered from a user gesture (click/touch) to allow sound on iOS.
// - If unlock fails (context still not running), we keep it retryable on next gesture.
// =========================
let _primeAudioPromise = null;
function primeAudio({ retry = false } = {}) {
  try {
    const rc = (window.Tone && Tone.getContext) ? Tone.getContext().rawContext : null;
    const running = rc && rc.state === "running";
    if (!retry && running && _primeAudioPromise) return _primeAudioPromise;
  } catch (e) {}

  if (_primeAudioPromise && !retry) return _primeAudioPromise;

  _primeAudioPromise = (async () => {
    try {
      if (window.Tone && Tone.start) await Tone.start();
    } catch (e) {}
    try {
      const rc = Tone.getContext().rawContext;
      if (rc && rc.state !== "running") await rc.resume();
    } catch (e) {}

    // Kick off/await instrument loading (fetch+decode can happen even if suspended)
    try {
      await Promise.all([
        ensurePiano(),   // Keys
        ensureOboe(),    // Melody
        ensureBass(),    // Bass
        ensureDrums()    // Drums
      ]);
    } catch (e) {}

    // If still not running (iOS can refuse if not a real gesture), allow retry next time
    try {
      const rc2 = Tone.getContext().rawContext;
      if (!rc2 || rc2.state !== "running") {
        _primeAudioPromise = null;
      }
    } catch (e) {
      _primeAudioPromise = null;
    }
  })();

  return _primeAudioPromise;
}


    Tone.Transport.bpm.value = project.bpm;

    function pitchToMidi(pitch) { return pitch; } // note.pitch는 이미 MIDI 번호

    
    
    // =========================
    // Master bus: route ALL audio (Tone + Soundfont) through one node so we can record/export.
    // =========================
    let MASTER_NODE = null; // native GainNode on Tone's raw AudioContext

    function ensureMasterNode() {
      if (MASTER_NODE) return MASTER_NODE;
      const toneCtx = (typeof Tone !== "undefined" && Tone.getContext) ? Tone.getContext() : null;
      const ac = (toneCtx && (toneCtx.rawContext || toneCtx._context || toneCtx.context)) || null;
      if (!ac) throw new Error("No AudioContext");

      // Create master gain node
      MASTER_NODE = ac.createGain();
      MASTER_NODE.gain.value = 1.0;

      // Connect master to speakers
      try { MASTER_NODE.connect(ac.destination); } catch (e) {}

      // Route Tone's Destination into MASTER_NODE (disconnect from direct destination if possible to avoid double audio)
      try {
        const dest = (Tone.getDestination) ? Tone.getDestination() : Tone.Destination;
        try { dest.disconnect(); } catch (e) {}
        try { dest.connect(MASTER_NODE); } catch (e) {}
      } catch (e) {
        // Fallback: best-effort connect without disconnect
        try { Tone.Destination.connect(MASTER_NODE); } catch (e2) {}
      }

      return MASTER_NODE;
    }

async function ensurePiano() {
      const audioCtx = Tone.getContext().rawContext;

      if (!pianoReadyPromise) {
        // Start fetching/decoding ASAP (does not start audio playback)
        pianoReadyPromise = Soundfont.instrument(audioCtx, "acoustic_grand_piano", { destination: ensureMasterNode() }).catch(() => null);
      }

      if (!pianoInst) pianoInst = await pianoReadyPromise;
      return pianoInst;
    }

    async function ensureOboe() {
      const audioCtx = Tone.getContext().rawContext;
      if (!oboeReadyPromise) {
        oboeReadyPromise = Soundfont.instrument(audioCtx, "oboe", { destination: ensureMasterNode() }).catch(() => null);
      }
      if (!oboeInst) oboeInst = await oboeReadyPromise;
      return oboeInst;
    }

    async function ensureBass() {
      const audioCtx = Tone.getContext().rawContext;
      if (!bassReadyPromise) {
        // GM Fingered Bass
        bassReadyPromise = Soundfont.instrument(audioCtx, "electric_bass_finger", { destination: ensureMasterNode() }).catch(() => null);
      }
      if (!bassInst) bassInst = await bassReadyPromise;
      return bassInst;
    }

    
async function ensureDrums() {
  // Sample-based GM drum kit using local MP3 files.
  // NOTE: This REQUIRES serving this folder over http(s) (e.g., VSCode Live Server / python -m http.server).
  // Opening the HTML via file:// will block fetch() and the samples won't load.
  if (!drumReadyPromise) {
    drumReadyPromise = (async () => {
      // Create players (each key is a MIDI note number string)
      const players = new Tone.Players({
        "36": "samples/drums/kick.mp3",
        "38": "samples/drums/snare.mp3",
        "42": "samples/drums/hihat_closed.mp3",
        "46": "samples/drums/hihat_open.mp3",
        "50": "samples/drums/tom1.mp3",
        "47": "samples/drums/tom2.mp3",
        "43": "samples/drums/tom3.mp3",
        "49": "samples/drums/crash.mp3",
        "51": "samples/drums/ride.mp3"
      }).toDestination();

      // Ensure buffers are loaded (Tone.js v15 uses global loader)
      await Tone.loaded();

      // Provide a soundfont-player-like interface: .play(midi, time, {duration, gain})
      return {
        _players: players,
        play(midi, time, opts = {}) {
          const key = String(Math.round(midi));
          const p = players.player(key);
          if (!p) return;

          // gain: 0..2 (linear) -> dB
          const gain = (typeof opts.gain === "number") ? opts.gain : 1.0;
          const g = Math.max(0.0, Math.min(2.0, gain));
          try { p.volume.value = 20 * Math.log10(Math.max(0.0001, g)); } catch (e) {}

          // Hi-hat choke group (Closed 42 / Open 46): they should not overlap.
          // We also play samples to their full length (no duration truncation).
          const keyNum = String(Math.round(midi));
          const isHat = (keyNum === "42" || keyNum === "46");
          if (isHat) {
            try { players.player("42")?.stop(time); } catch (e) {}
            try { players.player("46")?.stop(time); } catch (e) {}
          }
          try {
            // Play full sample length (ignore note length)
            p.start(time);
          } catch (e) {
            // If buffer isn't loaded yet, ignore quietly
          }
        }
      };
    })();
  }
  if (!drumInst) drumInst = await drumReadyPromise;
  return drumInst;
}

// =========================
// Mix / Gain Staging (simple)
// - Drum samples are typically much louder than SoundFont instruments.
// - We apply per-track gain multipliers (linear) when scheduling/previewing.
// - This is intentionally simple (no compressor/limiter yet) to keep the code stable.
// =========================
const TRACK_GAIN = {
  drums: 0.50,
  melody: 1.50,
  keys: 1.50,
  bass: 1.50
};

function getTrackGain(tid) {
  return (TRACK_GAIN && typeof TRACK_GAIN[tid] === "number") ? TRACK_GAIN[tid] : 1.0;
}

function getActiveInstrument() {
  if (activeTrackId === "drums") return ensureDrums();
  if (activeTrackId === "melody") return ensureOboe();
  if (activeTrackId === "bass") return ensureBass();
  // keys + default
  return ensurePiano();
}

function auditionPitch(pitchMidi) {
  // Safe audition helper used by note placement / selection.
  // pitchMidi is always a MIDI note number (drums use GM note numbers like 36/38/42...).
  try {
    const audioCtx = Tone.getContext().rawContext;
    const now = audioCtx.currentTime;
	    Promise.resolve(getActiveInstrument()).then(inst => {
      if (!inst) return;
      const isDrum = (activeTrackId === "drums");
      const dur = isDrum ? undefined : 0.60;
	      const base = 0.90;
	      const g = base * getTrackGain(activeTrackId);
	      inst.play(pitchMidi, now, { duration: dur, gain: g });
    }).catch(() => {});
  } catch (e) {}
}





    async function play() {
  try{ await primeAudio(); }catch(e){}
      stopArmed = false;
  if (typeof primeAudio==='function') await primeAudio();
  // Make sure all instruments are loaded so per-track scheduling is stable
  await Promise.all([ensurePiano(), ensureOboe(), ensureBass(), ensureDrums()]);

  // 사용자 제스처 이후 오디오 시작(필수)
  await Tone.start();

  Tone.Transport.stop();
  Tone.Transport.cancel();
  Tone.Transport.bpm.value = project.bpm;

  // 커서 위치에서 시작
  Tone.Transport.position = colToTransportPos(cursorCol);

  // Schedule notes
  if (typeof viewMode !== "undefined" && viewMode === "full") {
    // Full view currently shows a single combined track in project.tracks[0]
    const instForTrack = (activeTrackId === "drums") ? drumInst
      : (activeTrackId === "melody") ? oboeInst
      : (activeTrackId === "bass") ? bassInst
      : pianoInst; // keys + default
    const notes = (project.tracks && project.tracks[0] && project.tracks[0].notes) ? project.tracks[0].notes : [];
    notes.forEach(note => {
      Tone.Transport.schedule((time) => {
	        const dur = (activeTrackId === "drums") ? undefined : lengthToSeconds(note.length, project.bpm);
	        const base = (activeTrackId === "drums") ? 1.0 : 0.9;
	        const g = base * getTrackGain(activeTrackId);
        instForTrack.play(
          pitchToMidi(note.pitch),
          time,
          { duration: dur, gain: g }
        );
      }, noteToTransportPos(note));
    });
  } else {
    // Part view: schedule all tracks from the current part (melody/keys/bass/drums)
    const part = project.parts[project.currentPartId];
    ensurePartTracks(part);
    TRACK_DEFS.forEach(def => {
      const tid = def.id;
      const instForTrack = (tid === "drums") ? drumInst
        : (tid === "melody") ? oboeInst
        : (tid === "bass") ? bassInst
        : pianoInst; // keys + default
      if (!instForTrack) return;
      const notes = (part.tracks[tid] && part.tracks[tid].notes) ? part.tracks[tid].notes : [];
      notes.forEach(note => {
        Tone.Transport.schedule((time) => {
	          const dur = (tid === "drums") ? undefined : lengthToSeconds(note.length, project.bpm);
	          const base = (tid === "drums") ? 1.0 : 0.9;
	          const g = base * getTrackGain(tid);
          instForTrack.play(
            pitchToMidi(note.pitch),
            time,
            { duration: dur, gain: g }
          );
        }, noteToTransportPos(note));
      });
    });
  }

  
    // =========================
    // Stage 4: Chord Auto-Play (Keys only, from Chord Track)
    // =========================
    try {
      const part = project.parts[project.currentPartId];
      if (part) {
        ensurePartChords(part);
        ensurePartTracks(part);
        const keysTrack = part.tracks["keys"];

        // Auto Chords toggle
        if (!autoChordEnabled) {
          // do not schedule any chord auto-play when disabled
        } else {


        // Pattern:
        // - halfbar: 1 stab per half-bar (2-beat feel)
        // - beat4 : stab on each beat (4-beat feel)  => 2 stabs per half-bar
        // - arp8  : 8th-note arpeggio inside each half-bar
        const pattern = (typeof chordRhythm === "string" && chordRhythm) ? chordRhythm : "beat4";

        const beatDur = lengthToSeconds(4, project.bpm) * 0.92;   // 1 beat (quarter)
        const halfbarDur = lengthToSeconds(8, project.bpm) * 0.92; // 2 beats
        const eighthDur = lengthToSeconds(2, project.bpm) * 0.92; // 8th

        function computeChordForSlot(degree, colStart) {
          // Voice-leading based on existing keys notes at this position (if any)
          let chord = [];
          try {
            chord = chooseVoicingWithVoiceLeading(degree, keysTrack, colStart) || [];
          } catch (e) {
            chord = diatonicTriad(degree, getChordCenterMidi());
          }
          if (!chord || chord.length === 0) chord = diatonicTriad(degree, getChordCenterMidi());
          return chord;
        }

        for (let i = 0; i < HALF_BARS_PER_PART; i++) {
          const slot = part.chords[i];
          const roman = slot ? (slot.roman || "") : "";
          if (!roman) continue;

          const degree = romanToDegree(roman);
          const colStart = i * 8; // 8 columns per half-bar

          if (pattern === "halfbar") {
            // 1 stab per half-bar
            Tone.Transport.schedule((time) => {
	              const chord = computeChordForSlot(degree, colStart);
	              const g = 0.90 * getTrackGain("keys");
	              chord.forEach(m => pianoInst.play(m, time, { duration: halfbarDur, gain: g }));
            }, colToTransportPos(colStart));
          } else if (pattern === "arp8") {
            // 8th arpeggio: 4 notes per half-bar (0,2,4,6)
            // Use a simple up-down shape [0,1,2,1] if triad; otherwise cycle.
            const offsets = [0, 2, 4, 6];
            offsets.forEach((off, idx) => {
              Tone.Transport.schedule((time) => {
                const chord = computeChordForSlot(degree, colStart);
                if (!chord || chord.length === 0) return;
                const order = [0, 1, 2, 1];
                const pick = order[idx % order.length] % chord.length;
	                const midi = chord[pick];
	                const g = 0.90 * getTrackGain("keys");
	                pianoInst.play(midi, time, { duration: eighthDur, gain: g });
              }, colToTransportPos(colStart + off));
            });
          } else {
            // Default: 4-beat feel (stab each beat) => 2 stabs per half-bar at 0 and 4
            const offsets = [0, 4];
            offsets.forEach((off) => {
              Tone.Transport.schedule((time) => {
	                const chord = computeChordForSlot(degree, colStart + off);
	                const g = 0.90 * getTrackGain("keys");
	                chord.forEach(m => pianoInst.play(m, time, { duration: beatDur, gain: g }));
              }, colToTransportPos(colStart + off));
            });
          }
        }

        }
      }
    } catch (e) {}

  Tone.Transport.start();
  startPlayheadLoop();
}


    // =========================
    // 다이아토닉 코드 (1~7) 연주
    // =========================
    
function getGridCenterMidi() {
  // pitches 배열이 높은->낮은 순일 수 있으니 중앙값 사용
  const sorted = [...pitches].sort((a,b)=>a-b);
  const mid = sorted[Math.floor(sorted.length / 2)];
  return mid;
}

function shiftChordIntoRange(chord, minP, maxP, target) {
  // chord 전체를 옥타브 단위로 이동시켜 평균이 target 근처가 되도록
  const avg = (arr) => arr.reduce((a,b)=>a+b,0)/arr.length;
  let c = [...chord];

  // 1) 평균을 target에 가깝게
  for (let i=0; i<8; i++) {
    const a = avg(c);
    if (a > target + 3) c = c.map(n => n - 12);
    else if (a < target - 3) c = c.map(n => n + 12);
    else break;
  }

  // 2) 범위 밖이면 다시 보정
  for (let i=0; i<8; i++) {
    const lo = Math.min(...c);
    const hi = Math.max(...c);
    if (lo < minP) c = c.map(n => n + 12);
    else if (hi > maxP) c = c.map(n => n - 12);
    else break;
  }

  // 마지막: 개별 음이 살짝 밖이면 nearest octave로 클램프
  c = c.map(n => {
    while (n < minP) n += 12;
    while (n > maxP) n -= 12;
    return n;
  });

  return c;
}
function rootMidiNear(center = 60) {
      // center 근처에서 현재 키 루트 pitch class에 맞는 MIDI를 찾는다.
      const pc = currentKeyRoot;
      let m = center;
      while (((m % 12) + 12) % 12 !== pc) m--;
      if (center - m > 6) m += 12;
      return m;
    }

    // degree: 1~7
    
    function getChordCenterMidi() {
      // 그리드의 중간 음역을 기준으로 코드 보이싱을 잡는다
      if (!Array.isArray(pitches) || pitches.length === 0) return 60;
      return pitches[Math.floor(pitches.length / 2)];
    }

    function transposeIntoRange(midi, minP, maxP) {
      let m = midi;
      while (m < minP) m += 12;
      while (m > maxP) m -= 12;
      return m;
    }

function diatonicTriad(degree, center = 60) {
      const scale = getScaleSemis(); // length 7
      const root = rootMidiNear(center);
      const d0 = degree - 1; // 0~6
      const steps = [0, 2, 4]; // 1-3-5

      return steps.map(step => {
        const idx = d0 + step;
        const oct = Math.floor(idx / 7) * 12;
        const deg = idx % 7;
        return root + scale[deg] + oct;
      });
    }

    
// =========================
// 코드 보이싱(자리바꿈) 개선: 공통음 유지 + 최소 이동
// =========================
function getNotesAtCursor(track, col) {
  const out = [];
  for (const n of track.notes) {
    if (posToCol(n.bar, n.beat) === col) out.push(n.pitch);
  }
  return out.sort((a,b)=>a-b);
}

function pitchClass(n) { return ((n % 12) + 12) % 12; }

function triadPitchClasses(degree) {
  // diatonicTriad 결과를 이용해 pitch class 3개를 얻는다
  const base = diatonicTriad(degree, getGridCenterMidi());
  const pcs = [];
  for (const n of base) {
    const pc = pitchClass(n);
    if (!pcs.includes(pc)) pcs.push(pc);
  }
  return pcs.slice(0, 3);
}

function generateTriadVoicings(pcs, minP, maxP, targetCenter) {
  // pcs length 3
  const baseOct = Math.floor(targetCenter / 12) * 12;

  // root position near center
  let base = pcs.map(pc => baseOct + pc).sort((a,b)=>a-b);
  // ascending
  for (let i=1; i<base.length; i++) while (base[i] < base[i-1]) base[i] += 12;

  const cands = [];

  const add = (arr) => {
    let c = arr.slice().sort((a,b)=>a-b);
    c = shiftChordIntoRange(c, minP, maxP, targetCenter);
    if (c.every(n => n >= minP && n <= maxP)) cands.push(c);
  };

  add(base);
  add([base[1], base[2], base[0] + 12]); // 1st inv
  add([base[2], base[0] + 12, base[1] + 12]); // 2nd inv

  // octave variants
  const seen = new Set();
  const expanded = [];
  for (const c of cands) {
    for (const k of [-24, -12, 0, 12, 24]) {
      const shifted = c.map(n => n + k);
      const fixed = shiftChordIntoRange(shifted, minP, maxP, targetCenter);
      const key = fixed.join(",");
      if (seen.has(key)) continue;
      seen.add(key);
      if (fixed.every(n => n >= minP && n <= maxP)) expanded.push(fixed);
    }
  }
  return expanded.length ? expanded : cands;
}

function scoreAgainstReference(ref, cand) {
  // ref, cand sorted length 3
  let s = 0;
  for (let i=0; i<3; i++) s += Math.abs(ref[i] - cand[i]);
  return s;
}

function commonToneBonus(ref, cand) {
  // common pitch classes bonus (lower is better)
  const refPcs = new Set(ref.map(pitchClass));
  const candPcs = new Set(cand.map(pitchClass));
  let common = 0;
  for (const pc of candPcs) if (refPcs.has(pc)) common++;
  if (common === 3) return -60;
  if (common === 2) return -30;
  if (common === 1) return -10;
  return 0;
}

function chooseVoicingWithVoiceLeading(degree, track, col) {
  const minP = Math.min(...pitches);
  const maxP = Math.max(...pitches);
  const center = getGridCenterMidi();

  const pcs = triadPitchClasses(degree);
  if (pcs.length < 3) {
    let chord = diatonicTriad(degree, center);
    return shiftChordIntoRange(chord, minP, maxP, center);
  }

  const candidates = generateTriadVoicings(pcs, minP, maxP, center);

  const existing = getNotesAtCursor(track, col);
  if (existing.length >= 3) {
    // choose a 3-note window closest to center
    let ref = existing.slice(0, 3);
    let bestDist = Infinity;
    for (let i=0; i<=existing.length-3; i++) {
      const w = existing.slice(i, i+3);
      const avg = (w[0] + w[1] + w[2]) / 3;
      const dist = Math.abs(avg - center);
      if (dist < bestDist) { bestDist = dist; ref = w; }
    }

    let best = candidates[0] || diatonicTriad(degree, center);
    let bestScore = Infinity;
    for (const c of candidates) {
      const score = scoreAgainstReference(ref, c) + commonToneBonus(ref, c);
      if (score < bestScore) { bestScore = score; best = c; }
    }
    return best;
  }

  // no reference: pick closest to center
  let best = candidates[0] || diatonicTriad(degree, center);
  let bestScore = Infinity;
  for (const c of candidates) {
    const avg = (c[0] + c[1] + c[2]) / 3;
    const score = Math.abs(avg - center);
    if (score < bestScore) { bestScore = score; best = c; }
  }
  return best;
}

async function playChord(degree) {
      if (typeof viewMode !== "undefined" && viewMode === "full") return;
    try{ primeAudio(); }catch(e){}
const inst = await ensurePiano();
  const audioCtx = Tone.getContext().rawContext;
  const now = audioCtx.currentTime;

  const track = project.tracks[0];
  const minP = Math.min(...pitches);
  const maxP = Math.max(...pitches);

  // 보이싱(자리바꿈) 선택: 공통음 유지 + 최소 이동
  let chord = chooseVoicingWithVoiceLeading(degree, track, cursorCol);

  // (안전) chord 내부 중복 제거 + 범위 필터
  chord = Array.from(new Set(chord)).filter(n => n >= minP && n <= maxP);

  const dur = 0.9;

  // 항상 오디션(미리듣기)
	  const g = 0.90 * getTrackGain("keys");
	  for (const p of chord) {
	    inst.play(p, now, { duration: dur, gain: g });
	  }

  // 정지 상태일 때만: 커서 위치에 "찍기"
  if (Tone.Transport.state !== "started") {
    const chordLen = insertLen;

  // remember current insert length for playhead advance
  lastInsertStep = insertLen;

    const bar = Math.floor(cursorCol / 16) + 1;
    const beat = (cursorCol % 16) + 1;

    pushHistory();

    for (const p of chord) {
      // 중복 방지: 같은 커서 위치(같은 col) + 같은 pitch가 이미 있으면 추가하지 않음
      const exists = track.notes.some(n =>
        posToCol(n.bar, n.beat) === cursorCol && n.pitch === p
      );
      if (exists) continue;

      track.notes.push({
        id: nextNoteId++,
        bar,
        beat,
        length: chordLen,
        pitch: p
      });
    }

    renderNotes();
      advanceCursorAfterInsert();
  }
}

document.addEventListener("keydown", (e) => {
      const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
      if (tag === "input" || tag === "select" || tag === "textarea") return;

      if (e.key >= "1" && e.key <= "7") {
        e.preventDefault();
        playChord(Number(e.key));
      }
    });
    

function stop() {
  const running = (Tone.Transport.state === "started");
  if (running) {
    // 1st press while playing: stop
    stopOnceInternal();
    stopArmed = true;
    return;
  }

  // If already stopped: always jump to start of current view
  // If already stopped: always jump to start of current view
  setCursorCol(0);
const wrap = document.querySelector(".gridwrap");
  if (wrap) wrap.scrollLeft = 0;
  stopArmed = false;
}


function stopOnceInternal() {
  if (Tone.Transport.state === "started") {
    const bpm = Tone.Transport.bpm.value;
    const secPer16 = (60 / bpm) / 4;
    const col = Math.max(0, Math.min(totalCols - 1, Math.floor(Tone.Transport.seconds / secPer16)));
    setCursorCol(col);
  }
  Tone.Transport.stop();
  Tone.Transport.cancel();
  stopPlayheadLoop();
}

    // =========================
    // MIDI 내보내기
    // =========================
    function exportMidi() {
      const midi = new Midi();
      midi.header.setTempo(project.bpm);

      project.tracks.forEach(trackData => {
        const midiTrack = midi.addTrack();
        midiTrack.name = trackData.name;

        trackData.notes.forEach(note => {
          midiTrack.addNote({
            midi: note.pitch,
            time: positionToSeconds(note.bar, note.beat, project.bpm),
            duration: lengthToSeconds(note.length, project.bpm),
            velocity: 0.8
          });
        });
      });

      const blob = new Blob([midi.toArray()], { type: "audio/midi" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "my_web_daw.mid";
      a.click();
      URL.revokeObjectURL(url);
    }

    // =========================
    // 초기화
    // =========================
    buildTimeline();
    buildGrid();
    renderNotes();
    applyKey();
  

// Range UI
const rangeSel = document.getElementById("rangeSel");
if (rangeSel) {
  rangeSel.addEventListener("change", () => setRangePreset(rangeSel.value));
  currentRangeKey = rangeSel.value;
  setRangePreset(rangeSel.value); // initial
}
    initInsertLenButtons();
// Chord preset UI (inactive until user picks one)
const chordPresetSel = document.getElementById("chordPresetSel");
const autoChordToggle = document.getElementById("autoChordToggle");

if (chordPresetSel) {
  chordPresetSel.value = activeChordPresetId || "";
  chordPresetSel.addEventListener("change", () => {
    activeChordPresetId = chordPresetSel.value || "";
    applyPresetToGridCells();
      applyChordPresetToChordTrack();
});
}
if (autoChordToggle) {
  autoChordToggle.checked = !!autoChordEnabled;
  autoChordToggle.addEventListener("change", () => {
    autoChordEnabled = !!autoChordToggle.checked;
  });
}
// Track UI (boot)
bindTrackUI();
updateTrackUI();
applyTrackMode();


// Warm up / unlock audio on the very first user gesture (iOS)
document.addEventListener('pointerdown', () => { try { primeAudio({ retry: true }); } catch(e) {} }, { once: true, passive: true });
document.addEventListener('touchstart', () => { try { primeAudio({ retry: true }); } catch(e) {} }, { once: true, passive: true });
try { ensurePiano(); } catch(e) {}
setCursorCol(0);
    updatePlayheadVisual(0);
    
// --- Start Overlay wiring (audio unlock) ---
(function initStartOverlay(){
  const overlay = document.getElementById('startOverlay');
  const btn = document.getElementById('startBtn');
  const msg = document.getElementById('startMsg');
  if (!overlay || !btn) return;

  // keep UI blocked until unlocked
  document.body.classList.add('needs-start');

  // file:// 에서 열면 샘플 로딩(fetch)이 막힙니다.
  try {
    if (location.protocol === 'file:' && msg) {
      msg.innerHTML = '⚠️ 이 파일을 더블클릭(file://)로 열면 드럼 샘플이 로드되지 않습니다.<br>VS Code <b>Live Server</b> 또는 <b>python -m http.server</b>로 실행해 주세요.';
    }
  } catch(e) {}

  let started = false;

  async function doStart(){
    if (started) return;
    btn.disabled = true;
    btn.textContent = '로딩중…';
    if (msg) msg.textContent = '사운드 준비중…';
    try {
      // primeAudio handles Tone.start + instrument warmup with retries
      await primeAudio({ retry: true });

      started = true;
      overlay.classList.add('hidden');
      document.body.classList.remove('needs-start');

      // restore button text for potential future use (not shown)
      btn.textContent = '시작!';
      if (msg) msg.textContent = '';
    } catch (e) {
      console.error(e);
      btn.disabled = false;
      btn.textContent = '시작!';
      if (msg) msg.textContent = '안되면 한 번 더 눌러주세요.';
    }
  }

  // User gesture: click/tap/pointerup
  btn.addEventListener('click', doStart, { passive: true });
  overlay.addEventListener('click', (e)=>{
    // click on backdrop also starts (but avoid double triggering when button click bubbles)
    if (e.target === overlay) doStart();
  }, { passive: true });
})();

</script>
</body>
</html>