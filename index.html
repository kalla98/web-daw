<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>My Web DAW</title>
  <style>
    body { font-family: system-ui, -apple-system, sans-serif; margin: 16px; }
    h1 { margin: 0 0 6px; }
    .legend { margin: 8px 0 12px; color: #555; font-size: 14px; }

    .toolbar {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 12px;
    }
    .toolbar input { width: 80px; }

    .topbar, .pianoroll {
      display: grid;
      grid-template-columns: 70px 1fr;
      gap: 8px;
      align-items: start;
      max-width: 980px;
    }
    .topbar { margin-bottom: 6px; }

    .labels {
      display: grid;
      gap: 0;              /* ✅ 줄간격 없애서 그리드랑 일치 */
      padding-top: 1px;    /* ✅ grid의 바깥 border(1px)만큼 맞춤 */
      border: 1px solid #ddd;
      border-right: none; /* 라벨-그리드 사이 중복 선 방지 */
      border-radius: 4px 0 0 4px;
      overflow: hidden;
    }

    .label {
      height: 22px;
      box-sizing: border-box;             /* ✅ border가 height 안에 포함되게 */
      border-bottom: 1px solid #e6e6e6;   /* ✅ grid cell과 같은 가로 줄 */
      border-radius: 0;                   /* ✅ 줄 정렬이 더 또렷해짐(원하면 다시 4px 줘도 됨) */
    }


    /* 타임라인 */
    .timeline { display: grid; font-size: 12px; color: #333; }
    .tick {
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f8f8f8;
      border: 1px solid #e6e6e6;
      border-left: none;
    }
    .tick:first-child { border-left: 1px solid #e6e6e6; }
    .tick.bar { font-weight: 600; background: #f1f1f1; }

    /* 그리드 + 노트 오버레이 */
    .gridWrap {
      position: relative;
      width: fit-content;
      touch-action: none;
    }
    .grid {
      display: grid;
      border: 1px solid #ddd;
      background: #fff;
    }
    .cell {
      width: 22px;
      height: 22px;
      border-right: 1px solid #e6e6e6;
      border-bottom: 1px solid #e6e6e6;
      cursor: pointer;
      background: transparent;
      user-select: none;
    }
    /* 마디 시작 (굵은 선) */
    .cell.barline { border-left: 2px solid rgba(0,0,0,0.14); }
    /* 박 시작 (연한 선) */
    .cell.beatline { box-shadow: inset 1px 0 0 rgba(0,0,0,0.08); }

    /* 노트 레이어 */
    .notesLayer {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }
    .note {
      position: absolute;
      height: 22px;
      border-radius: 4px;
      background: #4a90e2;
      box-shadow: 0 0 0 1px rgba(0,0,0,0.08) inset;
    }
    .note.editing {
      box-shadow:
        0 0 0 2px rgba(0,0,0,0.25) inset,
        0 0 0 1px rgba(0,0,0,0.10);
    }

    button:focus { outline: none; }
  </style>
</head>

<body>
  <h1>My Web DAW</h1>
  <div class="toolbar">
    <button onclick="play()">재생</button>
    <button onclick="stop()">정지</button>
    <button onclick="exportMidi()">MIDI로 저장</button>
    <button onclick="undo()">Undo</button>

    <span style="margin-left:10px;">BPM</span>
    <input id="bpm" type="number" min="30" max="240" step="1" value="90" />
    <button onclick="applyBpm()">적용</button>

    <button onclick="clearNotes()" style="margin-left:auto;">노트 전체 삭제</button>
  </div>

  <div class="legend">
    16분 해상도(1박=4칸) · 4마디 · 클릭=생성(16분 1칸) · 드래그=길이 · 시작칸 클릭=삭제 · Cmd/Ctrl+Z=Undo
  </div>

  <div class="topbar">
    <div></div>
    <div id="timeline" class="timeline"></div>
  </div>

  <div class="pianoroll">
    <div id="labels" class="labels"></div>

    <div class="gridWrap" id="gridWrap">
      <div id="grid" class="grid"></div>
      <div id="notesLayer" class="notesLayer"></div>
    </div>
  </div>

  <script src="https://unpkg.com/tone/build/Tone.js"></script>
  <script src="https://unpkg.com/@tonejs/midi/build/Midi.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/soundfont-player@0.12.0/dist/soundfont-player.min.js"></script>

  <script>
    // =========================
    // 설정
    // =========================
    const CELL = 22;
    const SUBDIV = 4; // 1박(4분) = 4칸 = 16분 해상도

    // =========================
    // 프로젝트 데이터
    // =========================
    const project = {
      bpm: 90,
      timeSignature: [4, 4],
      bars: 4,
      tracks: [{ name: "Piano", notes: [] }]
    };

    // =========================
    // 피아노롤 설정
    // =========================
    const PITCH_MIN = 48; // C3
    const PITCH_MAX = 71; // B4

    const beatsPerBar = project.timeSignature[0]; // 4
    const totalCols = project.bars * beatsPerBar * SUBDIV; // 4 bars * 4 beats * 4 = 64

    const pitches = [];
    for (let p = PITCH_MAX; p >= PITCH_MIN; p--) pitches.push(p);

    const pitchToRow = new Map();
    pitches.forEach((p, i) => pitchToRow.set(p, i));

    let nextNoteId = 1;

    // =========================
    // 시간 변환 (마디/16분 -> 초)
    // =========================
    function positionToSeconds(bar, beat16, bpm) {
      const sixteenth = (60 / bpm) / SUBDIV;
      return (bar - 1) * beatsPerBar * SUBDIV * sixteenth
           + (beat16 - 1) * sixteenth;
    }
    function lengthToSeconds(length16, bpm) {
      return length16 * (60 / bpm) / SUBDIV;
    }

    function pitchToMidi(pitch) {
      return pitch; // note.pitch가 이미 midi
    }


    // =========================
    // 위치 변환
    // =========================
    function posToCol(bar, beat16) {
      return (bar - 1) * beatsPerBar * SUBDIV + (beat16 - 1);
    }
    function findNoteIndexAtStart(trackNotes, bar, beat16, pitch) {
      return trackNotes.findIndex(n => n.bar === bar && n.beat === beat16 && n.pitch === pitch);
    }

    // 클릭한 col(0-base)이 기존 노트의 범위(start~end)에 포함되는지 찾기
    function findNoteIndexCovering(trackNotes, col, pitch) {
      return trackNotes.findIndex(n => {
        if (n.pitch !== pitch) return false;
        const startCol = posToCol(n.bar, n.beat);
        const endCol = startCol + Math.max(1, n.length) - 1;
        return col >= startCol && col <= endCol;
    });
  }


    // =========================
    // UI 엘리먼트
    // =========================
    const labelsEl = document.getElementById("labels");
    const gridWrapEl = document.getElementById("gridWrap");
    const gridEl = document.getElementById("grid");
    const notesLayerEl = document.getElementById("notesLayer");
    const timelineEl = document.getElementById("timeline");
    const bpmEl = document.getElementById("bpm");

    function midiToName(m) {
      const names = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
      const name = names[m % 12];
      const oct = Math.floor(m / 12) - 1;
      return `${name}${oct}`;
    }

    function buildTimeline() {
      timelineEl.style.gridTemplateColumns = `repeat(${totalCols}, ${CELL}px)`;
      timelineEl.innerHTML = "";

      for (let col = 0; col < totalCols; col++) {
        const bar = Math.floor(col / (beatsPerBar * SUBDIV)) + 1;
        const beat16 = (col % (beatsPerBar * SUBDIV)) + 1;

        const tick = document.createElement("div");
        tick.className = "tick";

        // 1) 마디 첫 칸에는 마디 번호
        // 2) 그 외에는 박(1~4)만 표시 (16분은 너무 복잡하니까)
        if (beat16 === 1) {
          tick.classList.add("bar");
          tick.textContent = `${bar}`;
        } else if ((beat16 - 1) % SUBDIV === 0) {
          tick.textContent = `${((beat16 - 1) / SUBDIV) + 1}`; // 2,3,4 박
        } else {
          tick.textContent = "";
        }

        timelineEl.appendChild(tick);
      }
    }

    function buildGrid() {
      // 라벨
      labelsEl.style.gridTemplateRows = `repeat(${pitches.length}, ${CELL}px)`;
      labelsEl.innerHTML = "";
      pitches.forEach(p => {
        const div = document.createElement("div");
        div.className = "label";
        div.textContent = midiToName(p);
        labelsEl.appendChild(div);
      });

      // 그리드
      gridEl.style.gridTemplateColumns = `repeat(${totalCols}, ${CELL}px)`;
      gridEl.style.gridTemplateRows = `repeat(${pitches.length}, ${CELL}px)`;
      gridEl.innerHTML = "";

      // 래퍼 크기
      const width = totalCols * CELL + 2;
      const height = pitches.length * CELL + 2;
      gridWrapEl.style.width = `${width}px`;
      gridWrapEl.style.height = `${height}px`;

      for (let row = 0; row < pitches.length; row++) {
        for (let col = 0; col < totalCols; col++) {
          const cell = document.createElement("div");
          cell.className = "cell";

          const bar = Math.floor(col / (beatsPerBar * SUBDIV)) + 1;
          const beat16 = (col % (beatsPerBar * SUBDIV)) + 1;
          const pitch = pitches[row];

          cell.dataset.bar = String(bar);
          cell.dataset.beat = String(beat16);
          cell.dataset.pitch = String(pitch);

          // 마디/박 경계 표시
          if (beat16 === 1) cell.classList.add("barline");
          if ((beat16 - 1) % SUBDIV === 0) cell.classList.add("beatline");

          gridEl.appendChild(cell);
        }
      }
    }

    // =========================
    // 노트 렌더(블록)
    // =========================
    function renderNotes(editingId = null) {
      notesLayerEl.innerHTML = "";

      const notes = project.tracks[0].notes;
      for (const n of notes) {
        const row = pitchToRow.get(n.pitch);
        if (row === undefined) continue;

        const startCol = posToCol(n.bar, n.beat);
        const length = Math.max(1, n.length);
        const endCol = Math.min(totalCols - 1, startCol + length - 1);

        const left = startCol * CELL + 1;
        const top = row * CELL + 1;
        const width = (endCol - startCol + 1) * CELL - 2;

        const div = document.createElement("div");
        div.className = "note";
        if (editingId && n.id === editingId) div.classList.add("editing");

        div.style.left = `${left}px`;
        div.style.top = `${top}px`;
        div.style.width = `${Math.max(6, width)}px`;

        notesLayerEl.appendChild(div);
      }
    }

    // =========================
    // Undo
    // =========================
    const history = [];
    const HISTORY_LIMIT = 50;

    function snapshot() {
      return JSON.parse(JSON.stringify(project.tracks[0].notes));
    }
    function pushHistory() {
      history.push(snapshot());
      if (history.length > HISTORY_LIMIT) history.shift();
    }
    function undo() {
      if (history.length === 0) return;
      project.tracks[0].notes = history.pop();
      renderNotes();
    }
    document.addEventListener("keydown", (e) => {
      const z = e.key.toLowerCase() === "z";
      if (z && (e.metaKey || e.ctrlKey)) {
        e.preventDefault();
        undo();
      }
    });

 

    // =========================
// 입력: 클릭 삭제 + 드래그 길이
// =========================
let dragState = null;

// beat16(0~15)을 쓰더라도 노트 객체 필드는 beat 하나로 통일한다.
// note = { id, bar, beat, length, pitch }  // length는 16분음표 단위 길이

function findNoteIndexAtStart(notes, bar, beat, pitch) {
  return notes.findIndex(
    (n) => n.bar === bar && n.pitch === pitch && n.beat === beat
  );
}

function findNoteIndexCovering(notes, bar, beat, pitch) {
  return notes.findIndex((n) => {
    if (n.bar !== bar) return false;
    if (n.pitch !== pitch) return false;
    return beat >= n.beat && beat < n.beat + n.length; // 몸통 포함
  });
}

gridEl.addEventListener("pointerdown", (e) => {
  const cell = document.elementFromPoint(e.clientX, e.clientY);
  if (!cell || !cell.classList.contains("cell")) return;

  e.preventDefault();
  gridEl.setPointerCapture(e.pointerId);

  const bar = Number(cell.dataset.bar);
  const beat = Number(cell.dataset.beat);   // (cell.dataset.beat = beat16)
  const pitch = Number(cell.dataset.pitch);
  const col = posToCol(bar, beat);

  const notes = project.tracks[0].notes;

  const idxStart = findNoteIndexAtStart(notes, bar, beat, pitch);
  const idxCover = findNoteIndexCovering(notes, bar, beat, pitch);

  // 1) 노트 시작칸 클릭: 드래그 길이조절 모드 (드래그 안 하면 삭제)
  if (idxStart >= 0) {
    pushHistory(); // 리사이즈 중 length가 계속 바뀌므로 시작 시점에 히스토리 저장

    dragState = {
      mode: "resize",
      pointerId: e.pointerId,
      noteIndex: idxStart,
      startCol: col,
      moved: false,
      created: false,
    };

    renderNotes(notes[idxStart].id);
    return;
  }

  // 2) 노트 몸통(늘어난 부분 포함) 클릭: 삭제 모드
  if (idxCover >= 0) {
    pushHistory();

    dragState = {
      mode: "delete",
      pointerId: e.pointerId,
      noteIndex: idxCover,
    };

    renderNotes(notes[idxCover].id);
    return;
  }

  // 3) 빈 칸 클릭: 새 노트 생성 + 리사이즈 모드(드래그로 길이 늘림)
  pushHistory();

  const n = { id: nextNoteId++, bar, beat, length: 1, pitch };
  notes.push(n);

  dragState = {
    mode: "resize",
    pointerId: e.pointerId,
    noteIndex: notes.length - 1,
    startCol: col,
    moved: false,
    created: true,
  };

  renderNotes(n.id);
});

gridEl.addEventListener("pointermove", (e) => {
  if (!dragState) return;
  if (dragState.mode !== "resize") return;

  const el = document.elementFromPoint(e.clientX, e.clientY);
  if (!el || !el.classList || !el.classList.contains("cell")) return;

  const bar = Number(el.dataset.bar);
  const beat = Number(el.dataset.beat);
  const col = posToCol(bar, beat);

  const notes = project.tracks[0].notes;
  const n = notes[dragState.noteIndex];
  if (!n) return;

  // 같은 행(같은 pitch)만 늘리고 싶다면 여기서 pitch 체크 추가 가능.
  // 지금은 마우스가 다른 pitch로 넘어가도 col 기준으로만 길이 계산.

  const endCol = Math.max(dragState.startCol, Math.min(totalCols - 1, col));
  const newLength = endCol - dragState.startCol + 1;

  if (newLength !== n.length) dragState.moved = true;
  n.length = Math.max(1, newLength);

  renderNotes(n.id);
});

function finishPointer() {
  if (!dragState) return;

  const notes = project.tracks[0].notes;

  if (dragState.mode === "delete") {
    // 몸통 클릭 삭제
    notes.splice(dragState.noteIndex, 1);
    renderNotes();
    dragState = null;
    return;
  }

  if (dragState.mode === "resize") {
    const n = notes[dragState.noteIndex];
    if (!n) {
      dragState = null;
      return;
    }

    // 드래그 없이 클릭만 한 경우:
    // - 새로 만든 노트(created)는 16분음표(1칸)로 남겨둔다.
    // - 기존 노트(start 클릭)는 삭제한다.
  if (!dragState.moved) {
    if (dragState.created) {
    // 새로 생성한 1칸짜리 노트 유지
      renderNotes();
      dragState = null;
      return;
    }
    // 기존 노트는 클릭만 하면 삭제
    notes.splice(dragState.noteIndex, 1);
    renderNotes();
    dragState = null;
    return;
  }


    // 드래그로 길이 변경한 경우: 이미 move에서 length 반영됨
    renderNotes();
    dragState = null;
    return;
  }

  dragState = null;
}

gridEl.addEventListener("pointerup", () => {
  finishPointer();
});

gridEl.addEventListener("pointercancel", () => {
  finishPointer();
});

let pianoInst = null;

async function ensurePiano() {
  // Tone의 AudioContext를 시작(사용자 클릭 후에만 가능)
  await Tone.start();

  // Tone이 내부적으로 쓰는 raw WebAudio context를 사용
  const audioCtx = Tone.getContext().rawContext;

  if (!pianoInst) {
    pianoInst = await Soundfont.instrument(audioCtx, "acoustic_grand_piano");
  }
  return pianoInst;
}



    // =========================
    // BPM / Clear
    // =========================
    function applyBpm() {
      const v = Number(bpmEl.value);
      if (!Number.isFinite(v) || v < 30 || v > 240) return;
      project.bpm = v;
      Tone.Transport.bpm.value = project.bpm;
    }
    function clearNotes() {
      pushHistory();
      project.tracks[0].notes = [];
      renderNotes();
    }

    // =========================
    // 재생/정지
    // =========================
    Tone.Transport.bpm.value = project.bpm;

async function play() {
  const inst = await ensurePiano();

  Tone.Transport.stop();
  Tone.Transport.cancel();
  Tone.Transport.bpm.value = project.bpm;

  project.tracks.forEach(track => {
    track.notes.forEach(note => {
      Tone.Transport.schedule((time) => {
        inst.play(
          pitchToMidi(note.pitch),
          time, // Tone과 같은 context time
          {
            duration: lengthToSeconds(note.length, project.bpm),
            gain: 0.7
          }
        );
      }, positionToSeconds(note.bar, note.beat, project.bpm));
    });
  });

  Tone.Transport.start();
}



    function stop() {
      Tone.Transport.stop();
      Tone.Transport.cancel();
    }

    // =========================
    // MIDI 내보내기
    // =========================
    function exportMidi() {
      const midi = new Midi();
      midi.header.setTempo(project.bpm);

      project.tracks.forEach(trackData => {
        const midiTrack = midi.addTrack();
        midiTrack.name = trackData.name;

        trackData.notes.forEach(note => {
          midiTrack.addNote({
            midi: note.pitch,
            time: positionToSeconds(note.bar, note.beat, project.bpm),
            duration: lengthToSeconds(note.length, project.bpm),
            velocity: 0.8
          });
        });
      });

      const blob = new Blob([midi.toArray()], { type: "audio/midi" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "my_web_daw.mid";
      a.click();
      URL.revokeObjectURL(url);
    }

    // =========================
    // 초기화
    // =========================
    buildTimeline();
    buildGrid();
    renderNotes();
  </script>

</body>
</html>
